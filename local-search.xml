<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高性能MySQL第三版笔记</title>
    <link href="/2023/09/27/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/27/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="高性能MySQL第三版笔记"><a href="#高性能MySQL第三版笔记" class="headerlink" title="高性能MySQL第三版笔记"></a>高性能MySQL第三版笔记</h1><h1 id="一些零散知识点"><a href="#一些零散知识点" class="headerlink" title="一些零散知识点"></a>一些零散知识点</h1><ul><li><strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li></ul><p>​INNER JOIN(也可以省略 INNER 使用 JOIN，效果一样)</p><h3 id="MySQL-关键字-USING-用法"><a href="#MySQL-关键字-USING-用法" class="headerlink" title="MySQL  关键字 USING 用法"></a><strong>MySQL  关键字 USING 用法</strong></h3><p>using()用于两张表的join查询，要求using()指定的列在两个表中均存在，并使用之用于join的条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 使用<span class="hljs-keyword">using</span><br><span class="hljs-keyword">SELECT</span><br>film.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br>sakila.film<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> sakila.film_actor <span class="hljs-keyword">USING</span> (film_id)<br><span class="hljs-keyword">WHERE</span><br>actor_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br># 等价得 使用 <span class="hljs-keyword">ON</span> 来操作<br><span class="hljs-keyword">SELECT</span><br>film.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br>sakila.film<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> sakila.film_actor <span class="hljs-keyword">ON</span> film_actor.film_id <span class="hljs-operator">=</span> film.film_id<br><span class="hljs-keyword">WHERE</span><br>actor_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h1 id="第6章-查询性能优化"><a href="#第6章-查询性能优化" class="headerlink" title="第6章 查询性能优化"></a>第6章 查询性能优化</h1><h2 id="6-7优化特定类型查询"><a href="#6-7优化特定类型查询" class="headerlink" title="6.7优化特定类型查询"></a>6.7优化特定类型查询</h2><h3 id="6-7-5优化LIMIT分页"><a href="#6-7-5优化LIMIT分页" class="headerlink" title="6.7.5优化LIMIT分页"></a><strong>6.7.5优化LIMIT分页</strong></h3><p>在系统中需要进行分页操作的时候，我们通常会使用 LIMIT 加上偏移量的办法实现，同时加上合适的 ORDER BY子句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>film_id,<br>description<br><span class="hljs-keyword">FROM</span><br>sakila.film<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>title<br>LIMIT <span class="hljs-number">5</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure><p>在数据过多时，可能往后翻很多页， 这个时候需要优化，<br>优化一，优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，</p><p>而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。<br>对于偏移量很大的时候，这样做的效率会提升非常大。考虑下面的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>film.film_id,<br>film.description<br><span class="hljs-keyword">FROM</span><br>sakila.film<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<br><span class="hljs-keyword">SELECT</span><br>film.film_id<br><span class="hljs-keyword">FROM</span><br>sakila.film<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>title<br>LIMIT <span class="hljs-number">5</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">500</span><br>) <span class="hljs-keyword">as</span> lim <span class="hljs-keyword">USING</span> (film_id);<br></code></pre></td></tr></table></figure><p>有时候也可以将LIMIT查询转换为已知位置的查询，<br>让MySQL 通过范围扫描获得到对应的结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> film_id, description <span class="hljs-keyword">FROM</span> sakila.film <span class="hljs-keyword">WHERE</span> film_id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">54</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> film_id;<br></code></pre></td></tr></table></figure><p>LIMIT和OFFSET的问题，其实是OFFSET的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。</p><p>如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用 OFFSET。例如，若需要按照租借记录做翻页，那么可以根据最新一条租借记录向后追溯，这种做法可行是因为租借记录的主键是单调增长的。首先使用下面的查询获得第一组结果 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sakila.rental <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rental_id <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>假设上面的查询返回的是主键为 16 049 到 16 030的租借记录，那么下一页查询就可以从16030这个点开始:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sakila.rental <span class="hljs-keyword">WHERE</span> rental id <span class="hljs-operator">&lt;</span> <span class="hljs-number">16030</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rental_id <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>该技术的好处是无论翻页到多么后面，其性能都会很好</p><h3 id="6-7-9使用用户自定义变量"><a href="#6-7-9使用用户自定义变量" class="headerlink" title="6.7.9使用用户自定义变量"></a>6.7.9使用用户自定义变量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-variable">@one</span> :<span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@min_actor</span> :<span class="hljs-operator">=</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(actor_id) <span class="hljs-keyword">FROM</span> sakila.actor);<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@last_week</span> :<span class="hljs-operator">=</span> <span class="hljs-built_in">CURRENT_DATE</span> <span class="hljs-operator">-</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> WEEK;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@one</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@min_actor</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@last_week</span>;<br></code></pre></td></tr></table></figure><h2 id="总结-6-9"><a href="#总结-6-9" class="headerlink" title="总结 6.9"></a>总结 6.9</h2><p>如果把创建高性能应用程序比作是一个环环相扣的“难题”，除了前面介绍的 schema索引和查询语句设计之外，查询优化应该是解开“难题”的最后一步了。要想写一个好的查询，你必须要理解 schema 设计、索引设计等，反之亦然。</p><p>理解查询是如何被执行的以及时间都消耗在哪些地方，这依然是前面我们介绍的响应时间的一部分。再加上一些诸如解析和优化过程的知识，就可以更进一步地理解上一章讨论的MySQL如何访问表和索引的内容了。这也从另一个维度帮助读者理解MySQL在访问表和索引时查询和索引的关系。</p><p>优化通常都需要三管齐下 :不做、少做、快速地做。我们希望这里的案例能够帮助你将理论和实践联系起来。</p><p>除了这些基础的手段，包括查询、表结构、索引等，MySQL 还有一些高级的特性可以帮助你优化应用，例如分区，分区和索引有些类似但是原理不同。MySQL还支持查询缓存，它可以帮你缓存查询结果，当完全相同的查询再次执行时，直接使用缓存结果 (回想一下，“不做”)。我们将在下一章中介绍这些特性。</p><h1 id="第7章-MySQL高级特性"><a href="#第7章-MySQL高级特性" class="headerlink" title="第7章 MySQL高级特性"></a>第7章 MySQL高级特性</h1><h2 id="7-1-分区表"><a href="#7-1-分区表" class="headerlink" title="7.1 分区表"></a>7.1 分区表</h2><p><strong>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象 (Handler Object)的封装。</strong></p><p>对分区表的请求，都会通过句柄对象转化成对存储引擎的接口调用。所以分区对于 SQL 层来说是一个完全封装底层实现的黑盒子，对应用是透明的，但是从底层的文件系统来看就很容易发现，每一个分区表都有一个使用 # 分隔命名的表文件。</p><p><strong>MySQL 实现分区表的方式一一对底层表的封装一一意味着索引也是按照分区的子表定义的，而没有全局索引。</strong></p><p>MySQL在创建表时使用PARTITION BY子定义每个分区存放的数据。</p><p>在执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无须扫描所有分区一一只需要查找包含需要数据的分区就可以了。<br><strong>分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表中。</strong>这样做可以将相关的数据存放在一起，另外，如果想一次批量删除整个分区的数据也会变得很方便。</p><p>分区表使用场景：</p><ul><li>表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。（例如微博数据）</li><li>分区表的数据更容易维护。可以对一个独立分区进行删除、优化、检查、修复等操作。</li><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备可以使用分区表来避免某些特殊的瓶颈。</li><li>如果需要，还可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好。</li></ul><p>分区表的限制，下面是其中比较重要的几点 :</p><ul><li>一个表最多只能有 1024 个分区。</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</li><li>分区表中无法使用外键约束。</li></ul><h3 id="7-1-1-分区表原理"><a href="#7-1-1-分区表原理" class="headerlink" title="7.1.1 分区表原理"></a>7.1.1 分区表原理</h3><p>如前所述，分区表由多个相关的底层表实现，这些底层表也是由句柄对象 (Handlerobject)表示，所以我们也可以直接访问各个分区。存储引擎管理分区的各个底层表和管理普通表一样(所有的底层表都必须使用相同的存储引擎)，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p><p>分区表上的操作按照下面的操作逻辑进行 :</p><p><strong>SELECT查询</strong><br>当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据。</p><p><strong>INSERT操作</strong><br>当写入一条记录时，分区层先打开并锁住所有的底层表，然后确定哪个分区接收这条记录，再将记录写入对应底层表。</p><p><strong>DELETE操作</strong><br>当删除一条记录时，分区层先打小并锁住所有的底层表，然后确定数据对应的分区最后对相应底层表进行删除操作。</p><p><strong>UPDATE操作</strong><br>当更新一条记录时，分区层先打开并锁住所有的底层表，MySQL 先确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区最后对底层表进行写入操作，并对原数据所在的底层表进行删除操作。</p><h3 id="7-1-2-分区表的类型"><a href="#7-1-2-分区表的类型" class="headerlink" title="7.1.2 分区表的类型"></a>7.1.2 分区表的类型</h3><p>MySQL 支持多种分区表。最多的是根据范围进行分区，每个分区存储落在某个范围的记录，分区表达式可以是列，也可以是包含列的表达式。例如，下表就可以将每一年的销售额存放在不同的分区里 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sales(<span class="hljs-keyword">order</span> <span class="hljs-type">date</span> DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>                   <span class="hljs-comment">-- Other columns omitted </span><br>                   ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>(<span class="hljs-keyword">YEAR</span>(<span class="hljs-keyword">order</span> <span class="hljs-type">date</span>)) (<br>                       <span class="hljs-keyword">PARTITION</span> P_2010 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2010</span>),<br>                       <span class="hljs-keyword">PARTITION</span> P_2011 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2011</span>),<br>                       <span class="hljs-keyword">PARTITION</span> P_2012 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2012</span>),<br>                       <span class="hljs-keyword">PARTITION</span> p_catchall <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE );<br></code></pre></td></tr></table></figure><p>PARTITION 分区子句中可以使用各种函数。但有一个要求，表达式返回的值要是一个确定的整数，且不能是一个常数。这里我们使用函数 YEAR(), 也可以使用其他函数,</p><p>如TO_DAYS()。根据时间间隔进行分区，是一种很常见的分区方式，后面我们还会再回过头来看这个例子，看看如何优化这个例子来避免一些问题。</p><p>MySQL还支持键值、哈希和列表分区，这其中有些还支持子分区，不过我们在生产环境中很少见到。</p><p>在我们看过的一个子分区的案例中，对一个类似于前面我们设计的按时间分区的InnoDB表，系统通过子分区可降低索引的互斥访问的竞争。最近一年的分区的数据会被非常频繁地访问，这会导致大量的互斥量的竞争。使用哈希子分区可以将数据切成多个小片大大降低互斥量的竞争问题。</p><p><strong>我们还看到的一些其他的分区技术包括</strong></p><ul><li>根据键值进行分区，来减少InnoDB的互斥量竞争使用。</li><li>数学模函数来进行分区，然后将数据轮询放入不同的分区。例如，可以对日期做模 7的运算，或者更简单地使用返回周几的函数，如果只想保留最近几天的数据这样分区很方便。</li><li>假设表有一个自增的主键列 id，希望根据时间将最近的热点数据集中存放。那么必须将时间戳包含在主键当中才行，而这和主键本身的意义相矛盾。这种情况下也可以使用这样的分区表达式来实现相同的目的:HASH(id DIV 1000000)，这将为100万数据建立一个分区。这样一方面实现了当初的分区目的，另一方面比起使用时间范围分区还避免了一个问题，就是当超过一定阀值时，如果使用时间范围分区就必须新增分区。</li></ul><h3 id="7-1-3-如何使用分区表"><a href="#7-1-3-如何使用分区表" class="headerlink" title="7.1.3 如何使用分区表"></a>7.1.3 如何使用分区表</h3><p>假设我们希望从一个非常大的表中查询出一段时间的记录，而这个表中包含了很多年的历史数据，数据是按照时间排序的，例如，希望查询最近几个月的数据，这大约有 10 亿条记录。可能过些年本书会过时，不过我们还是假设使用的是 2012 年的硬件设备，而原表中有 10TB 的数据，这个数据量远大于内存，并且使用的是传统硬盘，不是闪存(多数 SSD 也没有这么大的空间)。你打算如何查询这个表?如何才能更高效?</p><p>首先很肯定:因为数据量巨大，肯定不能在每次查询的时候都扫描全表。考虑到索引在空间和维护上的消耗，也不希望使用索引。即使真的使用索引，你会发现数据并不是按照想要的方式聚集的，而且会有大量的碎片产生，最终会导致一个查询产生成千上万的随机 I&#x2F;0，应用程序也随之僵死。情况好一点的时候，也许可以通过一两个索引解决一些问题。不过多数情况下，索引不会有任何作用。这时候只有两条路可选:让所有的查询都只在数据表上做顺序扫描，或者将数据表和索引全部都缓存在内存里。</p><p>这里需要再陈述一遍:<strong>在数据量超大的时候，B-Tree 索引就无法起作用了。</strong>除非是索引覆盖查询，否则数据库服务器需要根据索引扫描的结果<strong>回表</strong>，<strong>查询所有符合条件的记录，如果数据量巨大，这将产生大量随机I&#x2F;0</strong>，随之，数据库的响应时间将大到不可接受的程度。另外，索引维护(磁盘空间、I&#x2F;0 操作)的代价也非常高。有些系统，如Infobright，意识到这一点，于是就完全放弃使用 B-Tree 索引，而选择了一些更粗粒度的但消耗更少的方式检索数据，例如在大量数据上只索引对应的一小块元数据。</p><p>这正是分区要做的事情。理解分区时还可以将其当作索引的最初形态，以代价非常小的方式定位到需要的数据在哪一片“区域”。在这片“区域”中，你可以做顺序扫描，可以建索引，还可以将数据都缓存到内存，等等。因为分区无须额外的数据结构记录每个分区有哪些数据一一分区不需要精确定位每条数据的位置，也就无须额外的数据结构所以其代价非常低。只需要一个简单的表达式就可以表达每个分区存放的是什么数据。</p><p>为了保证大数据量的可扩展性，一般有下面两个策略:</p><p><strong>全量扫描数据，不要任何索引</strong><br>可以使用简单的分区方式存放表，不要任何索引，根据分区的规则大致定位需要的数据位置。只要能够使用 WHERE 条件，将需要的数据限制在少数分区中，则效率是很高的。当然，也需要做一些简单的运算保证查询的响应时间能够满足需求。使用该策略假设不用将数据完全放入到内存中，同时还假设需要的数据全都在磁盘上，因为内存相对很小，数据很快会被挤出内存，所以缓存起不了任何作用。这个策略适用于以正常的方式访问大量数据的时候。警告:后面我们会详细解释，必须将查询需要扫描的分区个数限制在一个很小的数量。</p><p><strong>索引数据，并分离热点</strong><br>如果数据有明显的“热点”, 而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效地使用缓存。</p><h3 id="7-1-4-什么情况下会出问题"><a href="#7-1-4-什么情况下会出问题" class="headerlink" title="7.1.4 什么情况下会出问题"></a>7.1.4 什么情况下会出问题</h3><p>上面我们介绍的两个分区策略都基于两个非常重要的假设:查询都能够过 (prunning掉很多额外的分区、分区本身并不会带来很多额外的代价。而事实证明，这两个假设在某些场景下会有问题。下面介绍一些可能会遇到的问题。</p><p><strong>NULL 值会使分区过滤无效</strong><br>关于分区表一个容易让人误解的地方就是分区的表达式的值可以是 NULL:第一个分区是一个特殊分区。假设按照 PARTITION BY RANGE YEAR(order date)分区，那么所有 order date 为 NULL 或者是一个非法值的时候，记录都会被存放到第一个分区.[^注1]</p><p>现在假设有下面的查询:WHERE order date BETWEEN 2012-01-0’ AND2012-01-31’。实际上，MySQL 会检查两个分区，而不是之前猜想的一个:它会检查 2012 年这个分区，同时它还会检查这个表的第一个分区。检查第一个分区是因为YEAR()函数在接收非法值的时候可能会返回 NULL值，那么这个范围的值可能会返回 NULL而被存放到第一个分区了。这一点对于其他很多函数，例如 TO DAYS()也一样。[^注2]</p><p>如果第一个分区非常大，特别是当使用“全量扫描数据，不要任何索引”的策时代价会非常大。而且扫描两个分区来查找列也不是我们使用分区表的初衷。为了避免这种情况，可以创建一个“无用”的第一个分区，例如，上面的例子中可以使用PARTITION p_nulls VALUES LESS THAN ()来创建第一个分区。如果插表中的数据都是有效的，那么第一个分区就是空的，这样即使需要检测第一个分区，代价也会非常小。</p><p>在MySQL 5.5中就不需要这个优化技巧了，因为可以直接使用列本身而不是基于列的函数进行分区:PARTITION BY RANGE COLUMNS(order date)。所以这个案例最好的解决方法是能够直接使用 MySQL5.5 的这个语法。</p><p>[^注2]: 因为可以在这里存放一个非法的日期，所以甚至当order date是一个非 NULL值的时候，仍然会出现这样情况。<br>[^注1]: 从用户角度来看，这应该是一个缺陷，不过从MySQL 开发者的角度来看这是一个特性</p><p><strong>分区列和索引列不匹配</strong><br>如果定义的索引列和分区列不匹配，会导致查询无法进行分区过滤。假设在列a上定义了索引，而在列 b上进行分区。因为每个分区都有其独立的索引，所以扫描列b上的索引就需要扫描每一个分区内对应的索引。如果每个分区内对应索引的非叶子节点都在内存中，那么扫描的速度还可以接受，但如果能跳过某些分区索引当然会更好。<strong>要避免这个问题，应该避免建立和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。</strong></p><p>听起来避免这个问题很简单，不过有时候也会遇到一些意想不到的问题。例如，在一个关联查询中，分区表在关联顺序中是第二个表，并且关联使用的索引和分区条件并不匹配。那么关联时针对第一个表符合条件的每一行，都需要访问并搜索第个表的所有分区。</p><p><strong>选择分区的成本可能很高</strong><br>如前所述分区有很多类型，不同类型分区的实现方式也不同，所以它们的性能也各不相同。尤其是范围分区，对于回答“这一行属于哪个分区”、“这些符合查询条件的行在哪些分区”这样的问题的成本可能会非常高，因为服务器需要扫描所有的分区定义的列表来找到正确的答案。类似这样的线性搜索的效率不高，所以随着分区数的增长，成本会越来越高.</p><p>我们所实际碰到的类似这样的最糟糕的一次问题是按行写入大量数据的时候。每写入一行数据到范围分区的表时，都需要扫描分区定义列表来找到合适的目标分区。可以通过限制分区的数量来缓解此问题，根据实践经验，对大多数系统来说，100个左右的分区是没有问题的。</p><p>其他的分区类型，比如键分区和哈希分区，则没有这样的问题</p><p><strong>打开并锁住所有底层表的成本可能很高</strong></p><p>当查询访问分区表的时候，MySQL 需要打开并锁住所有的底层表，这是分区表的另一个开销。这个操作在分区过滤之前发生，所以无法通过分区过滤降低此开销，并且该开销也和分区类型无关，会影响所有的查询。这一点对一些本身操作非常快的查询，比如根据主键查找单行，会带来明显的额外开销。可以用批量操作的方式来降低单个操作的此类开销，例如使用批量插入或者 LOAD DATA NFILE、一次删除多行数据，等等。当然同时还是需要限制分区的个数。</p><p><strong>维护分区的成本可能很高</strong><br>某些分区维护操作的速度会非常快，例如新增或者删除分区(当删除一个大分区可能会很慢，不过这是另一回事)。而有些操作，例如重组分区或者类似 ALTER 语句的重组分区的原理与 ALTER类似，先创建一个临时的操作:这类操作需要复制数据。分区，然后将数据复制到其中，最后再删除原分区。</p><p>如上所述，分区表不是什么“银弹”。下面是目前分区实现中的一些其他限制 :</p><ul><li>所有分区都必须使用相同的存储引擎</li><li>分区函数中可以使用的函数和表达式也有一些限制</li><li>某些存储引擎不支持分区。</li><li>对于MyISAM的分区表，不能再使用 LOAD INDEX INTOCACHE操作</li><li>对于 MyISAM 表，使用分区表时需要打开更多的文件描述符。虽然看起来是一个表其实背后有很多独立的分区，每一个分区对于存储引擎来说都是一个独立的表。这样即使分区表只占用一个表缓存条目，文件描述符还是需要多个。因此，即使已经配置了合适的表缓存，以确保不会超过操作系统的单个进程可以打开的文件描述符的个数，但对于分区表而言，还是会出现超过文件描述符限制的问题。</li></ul><p>最后，需要指出的是较老版本的 MySQL 问题会更多些。所有的软件都是有 bug的。分区表在MySQL 5.1中引入，在后面的 5.1.40和5150之后修复了很多分区表的 bug。在MySQL 5.5 中，分区表又做了很多改进，这才使得分区表可以逐步考用在生产环境了在即将发布的MySQL 5.6版本中，分区表做了更多的增强，例如新引的ALTER TABLEEXCHANGE PARTITION.</p><h3 id="7-1-5-查询优化"><a href="#7-1-5-查询优化" class="headerlink" title="7.1.5 查询优化"></a>7.1.5 查询优化</h3><p>引入分区给查询优化带来了一些新的思路 (同时也带来新的 bug)。分区最大的优点就是优化器可以根据分区函数来过滤一些分区。根据粗粒度索引的优势，通过分区过滤通常可以让查询扫描更少的数据 (在某些场景下)。</p><p>所以，对于访问分区表来说，很重要的一点是要在 WHERE 条件中带入分区列，有时候即使看似多余的也要带上，这样就可以让优化器能够过滤掉无须访问的分区。如果没有这些条件，MySQL就需要让对应存储引擎访问这个表的所有分区，如果表非常大的话就可能会非常慢。</p><p>使用EXPLAIN PARTITION 可以观察优化器是否执行了分区过滤，下面是一个示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN PARTITIONS <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Sales;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 结果</span><br><span class="hljs-string">id:1</span><br><span class="hljs-attr">select type:</span> <span class="hljs-string">SIMPLE</span><br><span class="hljs-string">table:sales</span> <span class="hljs-string">by_day</span><br><span class="hljs-string">partitions:P_2010,p_2011,P_2012</span><br><span class="hljs-string">type:ALL</span><br><span class="hljs-string">possible_keys:NULL</span><br><span class="hljs-string">key:NULL</span><br><span class="hljs-attr">key_len:</span> <span class="hljs-literal">NULL</span><br><span class="hljs-attr">ref:</span> <span class="hljs-literal">NULL</span><br><span class="hljs-attr">rows:</span> <span class="hljs-number">3</span><br><span class="hljs-attr">Extra:</span><br></code></pre></td></tr></table></figure><p>正如你所看到的，这个查询将访问所有的分区。下面我们在 WHERE 条中再加入一个时间限制条件:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN PARTITIONS <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> salesby_day <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">day</span> <span class="hljs-operator">&gt;</span><span class="hljs-number">2011</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 结果</span><br><span class="hljs-string">id:1</span><br><span class="hljs-attr">select_type:</span> <span class="hljs-string">SIMPLE</span><br><span class="hljs-attr">table:</span> <span class="hljs-string">sales</span><br><span class="hljs-attr">by_daypartitions:</span> <span class="hljs-string">p_2011,p_2012</span><br></code></pre></td></tr></table></figure><p>MySQL 优化器已经很善于过滤分区。比如它能够将范围条件转化为离散的值列表，并根据列表中的每个值过滤分区。然而，优化器也不是万能的。下面查询的 WHERE条件理论上可以过滤分区，但实际上却不行 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN PARTITIONS <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sales <span class="hljs-keyword">by</span> <span class="hljs-keyword">day</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(<span class="hljs-keyword">day</span>) <span class="hljs-operator">=</span> <span class="hljs-number">2010</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 结果<br>id: <span class="hljs-number">1</span><br>select_type: SIMPLE<br><span class="hljs-keyword">table</span>: sales<br>by_daypartitions:p_2010,p_2011,p_2012<br></code></pre></td></tr></table></figure><p>MySQL 只能在使用分区函数的列本身进行比较时才能过滤分区，而不能根据表达式的值去过滤分区，即使这个表达式就是分区函数也不行。这就和查询中使用独立的列才能使用索引的道理是一样的(参考第 5 章的相关内容)。所以只需要把上面的查询等价地改写为如下形式即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN PARTITIONS <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sales by_day <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">day</span> BETWEEN2010<span class="hljs-number">-01</span><span class="hljs-number">-01</span><span class="hljs-string">&#x27;AND 2010-12-31;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">id:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">select_type:</span> <span class="hljs-string">SIMPLE</span><br><span class="hljs-attr">table:</span> <span class="hljs-string">sales_by_day</span><br><span class="hljs-attr">partitions:</span> <span class="hljs-string">p_2010</span><br></code></pre></td></tr></table></figure><p>这里写的 WHERE条件中带入的是分区列，而不是基于分区列的表达式，所以优化器能够利用这个条件过滤部分分区。一个很重要的原则是: 即便在创建分区时可以使用表达式，但在查询时却只能根据列来过滤分区。</p><p>优化器在处理查询的过程中总是尽可能聪明地去过滤分区。例如，若分区表是关联操作中的第二张表，且关联条件是分区键，MySQL就只会在对应的分区里匹配行。(EXPLAIN无法显示这种情况下的分区过滤，因为这是运行时的分区过滤，而不是查询优化阶段。)</p><h3 id="7-1-6-合并表"><a href="#7-1-6-合并表" class="headerlink" title="7.1.6 合并表"></a><del>7.1.6 合并表</del></h3><p>合并表(Merge table) 是一种早期的、简单的分区实现，和分区表相比有一些不同的限制,并且缺乏优化。分区表严格来说是一个逻辑上的概念,用户无法访问底层的各个分区对用户来说分区是透明的。但是合并表允许用户单独访问各个子表。分区表和优化器的结合更紧密，这也是未来发展的趋势，而<strong>合并表则是一种将被淘汰的技术，在未来的版本中可能被删除。</strong></p><h2 id="7-2-视图"><a href="#7-2-视图" class="headerlink" title="7.2 视图"></a>7.2 视图</h2><p>MySQL 5.0 版本之后开始引入视图。视图本身是一个虚拟表，不存放任何数据。在使用SQL 语句访问视图的时候，它返回的数据是 MySQL 从其他表中生成的。视图和表是在同一个命名空间，MySQL 在很多地方对于视图和表是同样对待的。不过视图和表也有不同，例如，不能对视图创建触发器，也不能使用 DROP TABLE 命令删除视图。</p><p>在MySQL官方手册中对如何创建和使用视图有详细的介绍，本书不会详细介绍这些我们将主要介绍视图是如何实现的，以及优化器如何处理视图，通过了解这些，希望可以让大家在使用视图时获得更高的性能。我们将使用示例数据库 world 来演示视图是如何工作的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">CREATE VIEW Oceania AS SELECT * FROM country WHERE Continent =&#x27;Oceania&#x27; WITH CHECK OPTION;<br></code></pre></td></tr></table></figure><p>实现视图最简单的方法是将 SELECT 语句的结果存放到临时表中。当需要访问视图的时候直接访问这个临时表就可以了。我们先来看看下面的查询 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT Code, Name FROM Oceania WHERE name=&#x27;Australia&#x27;; <br></code></pre></td></tr></table></figure><p>下面是使用临时表来模拟视图的方法。这里临时表的名字是为演示用的 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">CREATE TEMPORARY TABLE TMP_Oceania_123 AS SELECT *FROM country WHERE Continent=&#x27;Oceania&#x27;;<br>SELECT Code, Name FROM TMP_Oceania_123 WHERE name=&#x27;Australia&#x27;;<br></code></pre></td></tr></table></figure><p>这样做会有明显的性能问题，优化器也很难优化在这个临时表上的查询。实现视图更好的方法是，重写含有视图的查询，将视图的定义 SOL 直接包含进查询的 SOL 中。下面的例子展示的是将视图定义的 SOL合并进查询 SOL 后的样子:</p><p>MySQL 可以使用这两种办法中的任何一种来处理视图。这两种算法分别称为合并算法(MERGE)和临时表算法 (TEMPTABLE)4如果可能，会尽可能地使用合并算法。MySQL甚至可以嵌套地定义视图，也就是在一个视图上再定义另一个视图。 可以在 EXPLAINEXTENDED之后使用SHOW WARNINGS来查看使用视图的查询重写后的结果。</p><p>如果是采用临时表算法实现的视图，EXPLAIN中会显示为派生表 (DERIVED)。图7-1展示了这两种实现的细节。</p><img src="/2023/09/27/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%94%E8%AE%B0/image-20230104232807095.png" class=""><p>如果视图中包含 GROUY BY、DISTINCT、任何聚合函数、UNION、子查询等，只要无法在原表记录和视图记录中建立一一映射的场景中，MySQL 都将使用临时表算法来实现视图。上面列举的可能不全，而且这些规则在未来的版本中也可能会改变。如果你想确定MySQL 到底是使用合并算法还是临时表算法，可以EXPLAIN一条针对视图的简单查询:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">EXPLAIN SELECT * FROM &lt;viewname&gt;;<br>EXPLAIN SELECT Code, Mame FROM Oceania; <br></code></pre></td></tr></table></figure><img src="/2023/09/27/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%94%E8%AE%B0/image-20230104233225549.png" class=""><p>这里的 select_type为“DERIVED”说明该视图是采用临时表算法实现的。不过要注意如果产生的底层派生表很大，那么执行 EXPLAIN可能会非常慢。因为在 MySQL 5.5和更老的版本中，EXPLAIN是需要实际执行并产生该派生表的。</p><p>视图的实现算法是视图本身的属性，和作用在视图上的查询语句无关。例如，可以为一<br>个基于简单查询的视图指定使用临时表算法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">CREATE ALGORITHM=TEMPTABLE VIEW v1 AS SELECT * FROM sakila.actor;<br></code></pre></td></tr></table></figure><p>实现该视图的 SOL 本身并不需要临时表，但基于该视图无论执行什么样的查询，视图都会生成一个临时表。</p><h3 id="7-2-1-可更新视图"><a href="#7-2-1-可更新视图" class="headerlink" title="7.2.1 可更新视图"></a>7.2.1 可更新视图</h3><p>可更新视图 (updatable view) 是指可以通过更新这个视图来更新视图涉及的相关表。只要指定了合适的条件，就可以更新、删除甚至向视图中写入数据。例如，下面就是一个合理的操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">UPDATE Oceania SET Population = Population * 1.1 WHERE Name = &#x27;Australia&#x27;;<br></code></pre></td></tr></table></figure><p>如果视图定义中包含了GROUP BY、UNION、聚合函数，以及其他一些特殊情况，就不能被更新了。更新视图的查询也可以是一个关联语句，但是有一个限制，被更新的列必须来自同一个表中。另外，所有使用临时表算法实现的视图都无法被更新。</p><p>在上一节定义视图时使用的 CHECK OPTION子句，表示任何通过视图更新的行，都必须符合视图本身的 WHERE 条件定义。所以不能更新视图定义列以外的列，比如上例中不能更新Continent列，也不能插入不同 Continent值的新数据，否则MySQL会报如下的错误 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">UPDATE Oceania SET Continent =&#x27;Atlantis&#x27;;<br>-- ERROR 1369(HY000): CHECK OPTION failedworld.Oceania;<br></code></pre></td></tr></table></figure><p>某些关系数据库允许在视图上建立 INSTEAD OF发器，通过触发器可以精确控制在修改视图数据时做些什么。不过 MySQL 不支持在视图上建任何触发器.</p><h3 id="7-2-2-视图对性能的影响"><a href="#7-2-2-视图对性能的影响" class="headerlink" title="7.2.2 视图对性能的影响"></a>7.2.2 视图对性能的影响</h3><p>多数人认为视图不能提升性能，实际上，在 MySQL 中某些情况下视图也可以帮助提升性能。而且视图还可以和其他提升性能的方式叠加使用。例如，在重构 schema 的时候可以使用视图，使得在修改视图底层表结构的时候，应用代码还可能继续不报错的运行<br>可以使用视图实现基于列的权限控制，却不需要真正的在系统中创建列权限，因此没有额外的开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">CREATE VIEW publicemployeeinfo ASSELECT firstname,lastname -- but not socialsecuritynumber <br>FROM private.employeeinfo;<br>GRANT SELECT ON public.* TO public user;<br></code></pre></td></tr></table></figure><p>有时候也可以使用伪临时视图实现一些功能。MySQL 虽然不能创建只在当前连接中存在的真正的临时视图，但是可以建一个特殊名字的视图，然后在连接结束的时候删除该视图。这样在连接过程中就可以在 FROM子句中使用这个视图，和使用子查询的方式完全相同，因为 MySQL在处理视图和处理子查询的代码路径完全不同，所以它们的性能也不同。下面是一个例子 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- Assuming 1234 is the result of CONNECTION ID()<br>CREATE VIEW temp.cost per_day_1234 AS SELECT DATE(ts) AS day,sum(cost) AS cost FROM logs.cost GROUP BY day;<br><br>SELECT c.day，c.cost，s.sales FROM temp.cost_per_day_1234 AS C INNER JOIN sales.sales per_day AS s USING(day);<br><br>DROP VIEW tempcost per day 1234;<br></code></pre></td></tr></table></figure><p>我们这里使用连接 ID 作为视图名字的一部分来避免冲突。在应用发生崩和别的外导致未清理临时视图的时候，这个技巧使得清理临时视图变得很简单。详细的信息可以参考后面的“丢失的临时表”。</p><p>使用临时表算法实现的视图，在某些时候性能会很糟糕(虽然可能比直接使用等效查询语句要好一点)。MySQL以递归的方式执行这类视图，先会执行外层查询，即使外层查询优化器将其优化得很好，但是 MySQL 优化器可能无法像其他的数据库那样做更多的内外结合的优化。外层查询的 WHERE条件无法“下推”到构建视图的临时表的查询中临时表也无法建立索引s。下面是一个例子，还是基于 temp.cost per_day_1234 这个视图:</p><p>视图还引入了一些并非 MySQL 特有的其他问题。很多开发者以为视图很简单，但实际上其背后的逻辑可能非常复杂。开发人员如果没有意识到视图背后的复杂性，很可能会以为是在不停地重复查询一张简单的表，而没有意识到实际上是代价高昂的视图。我们见过不少案例，一条看起来很简单的查询，EXPLAIN出来却有几百行，因为其中一个或者多个表，实际上是引用了很多其他表的视图。</p><p>如果打算使用视图来提升性能，需要做比较详细的测试。即使是合并算法实现的视图也会有额外的开销，而且视图的性能很难预测。在 MySQL 优化器中，视图的代码执行路径也完全不同，这部分代码测试还不够全面，可能会有一些隐藏缺陷和问题。所以，我们认为视图还不是那么成熟。例如，我们看到过这样的案例，复杂的视图和高并发的查询导致查询优化器花了大量时间在执行计划生成和统计数据阶段，这甚至会导致 MySQL服务器僵死，后来通过将视图转换成等价的查询语句解决了问题。这也说明视图一一即使是使用合并算法实现的一一并不总是有很优化的实现。</p><h3 id="7-2-3-视图的限制"><a href="#7-2-3-视图的限制" class="headerlink" title="7.2.3 视图的限制"></a>7.2.3 视图的限制</h3><p>在其他的关系数据库中你可能使用过物化视图，MySQL 还不支持物化视图 (物化视图是指将视图结果数据存放在一个可以查看的表中，并定期从原始表中刷新数据到这个表中)。MySQL也不支持在视图中创建索引。不过，可以使用构建缓存表或者汇总表的办法来模拟物化视图和索引。可以直接使用Justin Swanharts的工具Flexviews 来实现这个目的。参考第 4章可以获得更多的相关细节。</p><p>MySQL视图实现上也有一些让人烦恼的地方。例如，MySQL 并不会保存视图定义的原始SOL语，所以如果打算通过执行 SHOW CREATE VIEW后再简单地修改其结果的方式来重新定义视图，可能会大失所望。SHOW CREATE VIEW出来的视图创建语句将以一种不友好的内部格式呈现，充满了各种转义符和引号，没有代码格式化，没有注释，也没有缩进。</p><h2 id="7-3-外键约束"><a href="#7-3-外键约束" class="headerlink" title="7.3 外键约束"></a>7.3 外键约束</h2><p>InnoDB是目前MySQL中唯一支持外键的内置存储引擎，所以如果需要外键支持那选择就不多了(PBXT也有外键支持)。</p><p>使用外键是有成本的。比如外键通常都要求每次在修改数据时都要在另外一张表中多执行一次查找操作。虽然InnoDB 强制外键使用索引,但还是无法消除这种约束检查的开销。<strong>如果外键列的选择性很低，则会导致一个非常大且选择性很低的索引。</strong>例如，在一个非常大的表上有 status 列，并希望限制这个状态列的取值，如果该列只能取三个值一一虽然这个列本身很小，但是如果主键很大，那么这个索引就会很大一一而且这个索引除了做这个外键限制，也没有任何其他的作用了。</p><p>不过，在某些场景下，外键会提升一些性能。<strong>如果想确保两个相关表始终有一致的数据那么使用外键比在应用程序中检查一致性的性能要高得多</strong>，此外，外键在相关数据的删除和更新上，也比在应用中维护要更高效，不过，<strong>外键维护操作是逐行进行的，所以这样的更新会比批量删除和更新要慢些.</strong></p><p>外键约束使得查询需要额外访问一些别的表，这也意味着需要额外的锁。如果向子表中写人一条记录，外键约束会让 InnoDB 检查对应的父表的记录，也就需要对父表对应记录进行加锁操作，来确保这条记录不会在这个事务完成之时就被删除了。这会导致额外的锁等待，甚至会导致一些死锁。因为没有直接访问这些表，所以这类死锁问题往往难以排查</p><p>有时，可以使用触发器来代替外键。对于相关数据的同时更新外键更合适，但是如果外键只是用作数值约束，那么触发器或者显式地限制取值会更好些。(这里，可以直接使用ENUM类型。</p><p>如果只是使用外键做约束，那通常在应用程序里实现该约束会更好。外键会带来很大的额外消耗。这里没有相关的基准测试的数据，不过我们碰到过很多案例，在对性能进行剖析时发现外键约束就是瓶颈所在，删除外键后性能立即大幅提升。</p><h2 id="7-4-在MySQL内部存储代码"><a href="#7-4-在MySQL内部存储代码" class="headerlink" title="7.4 在MySQL内部存储代码"></a>7.4 在MySQL内部存储代码</h2><p><strong>MySQL 允许通过触发器、存储过程、函数的形式来存储代码</strong>。从MySQL 5.1开始，还可以在<strong>定时任务中存放代码</strong>，这个定时任务也被称为<strong>“事件”</strong>。<strong>存储过程和存储函数都被统称为“存储程序”。</strong></p><p>这四种存储代码都使用特殊的 SOL 语句扩展，它包含了很多过程处理语法，例如循环和条件分支等 。<strong>不同类型的存储代码的主要区别在于其执行的上下文一一也就是其输人和输出。存储过程和存储函数都可以接收参数然后返回值，但是触发器和事件却不行</strong>。</p><p>有人倡导使用存储代码，也有人反对。这里我们不站在任何一边，只是列举一下在MySQL 中使用存储代码的优点和缺点。首先，它有如下优点 :</p><ul><li>它在服务器内部执行,离数据最近,另外在服务器上执行还可以节省带宽和网络延迟。</li><li>这是一种代码重用。可以方便地统一业务规则，保证某些行为总是一致，所以也可以为应用提供一定的安全性。</li><li>它可以简化代码的维护和版本更新。</li><li>它可以帮助提升安全，比如提供更细粒度的权限控制。一个常见的例子是银行用于转移资金的存储过程:这个存储过程可以在一个事务中完成资金转移和记录用于审计的日志。应用程序也可以通过存储过程的接口访问那些没有权限的表。</li><li>服务器端可以缓存存储过程的执行计划，这对于需要反复调用的过程，会大大降低消耗。</li><li>因为是在服务器端部署的，所以备份、维护都可以在服务器端完成。所以存储程序的维护工作会很简单。它没什么外部依赖，例如，不依赖任何 Perl包和其他不想在服务器上部署的外部软件。</li><li>它可以在应用开发和数据库开发人员之间更好地分工。不过最好是由数据库专家来开发存储过程，因为不是每个应用开发人员都能写出高效的 SOL查询。</li></ul><p>存储代码也有如下缺点:</p><ul><li>MySQL本身没有提供好用的开发和调试工具，所以编写MySQL的存储代码比其他的数据库要更难些。</li><li>较之应用程序的代码，存储代码效率要稍微差些。例如，存储代码中可以使用的函数非常有限，所以使用存储代码很难编写复杂的字符串维护功能，也很难实现大复杂的逻辑。</li><li>存储代码可能会给应用程序代码的部署带来额外的复杂性。原本只需要部署应用代码和库表结构变更，现在还需要额外地部署 MySQL内部的存储代码因为存储程序都部署在服务器内，所以可能有安全隐患。如果将非标准的加密功能放在存储程序中，那么若数据库被攻破，数据也就泄漏了。但是若将加密函数放在应用程序代码中，那么攻击者必须同时攻破程序和数据库才能获得数据存储过程会给数据库服务器增加额外的压力，而数据库服务器的扩展性相比应用服务器要差很多。</li><li>MySQL 并没有什么选项可以控制存储程序的资源消耗，所以在存储过程中的一个小错误，可能直接把服务器拖死。</li></ul><h3 id="7-4-1-存储过程和函数"><a href="#7-4-1-存储过程和函数" class="headerlink" title="7.4.1 存储过程和函数"></a>7.4.1 存储过程和函数</h3><p>MySQL的架构本身和优化器的特性使得存储代码有一些天然的限制，它的性能也一定程度受限于此。在本书编写的时候，有如下的限制 :</p><ul><li><p>优化器无法使用关键字 DETERMINISTIC来优化单个查询中多次调用存储函数的情况。</p></li><li><p>优化器无法评估存储函数的执行成本。</p></li><li><p>每个连接都有独立的存储过程的执行计划缓存。如果有多个连接需要调用同一个存储过程，将会浪费缓存空间来反复缓存同样的执行计划。(如果使用的是连接池或者是持久化连接，那么执行计划缓存可能会有更长的生命周期。)</p></li><li><p>存储程序和复制是一组诡异组合。如果可以，最好不要复制对存储程序的调用。直接复制由存储程序改变的数据则会更好。MySQL 5.1 引的行复制能够改善这个问题。如果在 MySQL5.0 中开启了二进制志，那么要么在所有的存储过程中都增加DETERMINISTIC限制或者设置 MySQL 的选项 log bin trust function creators。</p></li></ul><p>我们通常会希望存储程序越小、越简单越好。希望将更加复杂的处理逻辑交给上层的应用实现，通常这样会使代码更易读、易维护，也会更灵活。这样做也会让你拥有更多的计算资源，潜在的还会让你拥有更多的缓存资源。</p><p>不过，对于某些操作，<strong>存储过程比其他的实现要快得多一一特别是当一个存储过程调用可以代替很多小查询的时候。如果查询很小，相比这个查询执行的成本</strong>，解析和网络开销就变得非常明显。为了证明这一点，我们先创建一个简单的存储过程，用来写入一定数量的数据到一个表中，下面是存储过程的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">DROP PROCEDURE IF EXISTS insert_many_rows;<br> <br>CREATE PROCEDURE insert_many_rows(IN loops INT)<br>BEGIN<br>DECLARE v1 INT;<br>SET v1 = loops;<br>WHILE v1 &gt;0 DO <br>INSERT INTO test(colum1, colum2, colum3) values(0,&#x27;qqqqqqqqqqwwwwwwwwwweeeeeeeeeerrrrrrrrrrtttttttttt&#x27;, &#x27;qqqqqqqqqqwwwwwwwwwweeeeeeeeeerrrr&#x27;);<br>SET v1 = v1 - 1;<br>END WHILE;<br>END;<br></code></pre></td></tr></table></figure><h3 id="7-4-2-触发器"><a href="#7-4-2-触发器" class="headerlink" title="7.4.2 触发器"></a>7.4.2 触发器</h3><p><strong>触发器可以让你在执行 INSERT、UPDATE或者 DELETE 的时候，执行一些特定的操作。</strong>可以在 MySQL中指定是在 SQL 语执行前触发还是在执行后触发。触发器本身没有返回值，不过它们可以读取或者改变触发 SOL 语句所影响的数据。所以，可以使用触发器实现一些强制限制，或者某些业务逻辑，否则，就需要在应用程序中实现这些逻辑。</p><p>因为使用触发器可以减少客户端和服务器之间的通信，所以触发器可以简化应用逻辑还可以提高性能。另外，还可以用于自动更新反范式化数据或者汇总表数据。例如，在示例数据库Sakila 中，我们可以使用触发器来维护 film text 表。</p><p>MySQL触发器的实现非常简单，所以功能也有限。如果你在其他数据库产品中已经重度依赖触发器，那么在使用 MySQL 的时候需要注意，很多时候 MySQL触发器的表现和预想的并不一样。特别需要注意以下几点 :</p><ul><li><strong>对每一个表的每一个事件，最多只能定义一个触发器 (换句话说，不能在 AFTERINSERT上定义两个触发器)。</strong></li><li><strong>MySQL 只支持“基于行的触发”一一也就是说，触发器始终是针对一条记录的，而不是针对整个 SOL语句的。</strong>如果变更的数据集非常大的话，效率会很低。</li></ul><p>下面这些触发器本身的限制也适用于MySQL :</p><ul><li>触发器可以掩盖服务器背后的工作，一个简单的 SQL 语句背后，因为触发器，可能包含了很多看不见的工作。例如，触发器可能会更新另一个相关表，那么这个触发器会让这条 SQL影响的记录数翻一倍。</li><li>触发器的问题也很难排查，如果某个性能问题和触发器相关，会很难分析和定位。</li><li>触发器可能导致死锁和锁等待。如果触发器失败，那么原来的 SQL 语句也会失败。如果没有意识到这其中是触发器在搞鬼，那么很难理解服务器抛出的错误代码是什么思。</li></ul><p>如果仅考虑性能，那么MySQL 触发器的实现中对服务器限制最大的就是它的“基于行的触发”设计。因为性能的原因，很多时候无法使用触发器来维护汇总和缓存表。使用触发器而不是批量更新的一个重要原因就是，使用触发器可以保证数据总是一致的。</p><p>如果仅考虑性能，那么 MySQL触发器的实现中对服务器限制最大的就是它的“基于行的触发”设计。因为性能的原因，很多时候无法使用触发器来维护汇总和缓存表。使用触发器而不是批量更新的一个重要原因就是，使用触发器可以保证数据总是一致的。</p><p>触发器并不能一定保证更新的原子性。例如，一个触发器在更新 MyISAM 表的时候，如果遇到什么错误，是没有办法做回滚操作的。这时，触发器可以抛出错误。假设你在一个MyISAM表上建立一个AFTER UPDATE的触发器，用来更新另一个MyISAM表。如果触发器在更新第二个表的时候遇到错误导致更新失败，那么第一个表的更新并不会回滚。</p><p><strong>在InnoDB 表上的触发器是在同一个事务中完成的，所以它们执行的操作是原子的，原操作和触发器操作会同时失败或者成功。</strong>不过，如果在 InnoDB 表上建发器去检查数据的一致性，需要特别小心MVCC，稍不小心，你可能会获得错误的结果。假设，你想实现外键约束，但是不打算使用InnoDB 的外键约束。若打算编写一个BEFORE INSERT触发器来检查写入的数据对应列在另一个表中是存在的，但若你在触发器中没有使用SELECT FOR UPDATE，那么并发的更新语可能会立刻更新对应记录，导致数据不一致。</p><p>我们不是危言耸听，让大家不要使用触发器。相反，触发器非常有用，尤其是实现一些约束、系统维护任务，以及更新反范式化数据的时候。</p><p>还可以使用触发器来记录数据变更日志。这对实现一些自定义的复制会非常方便，比如需要先断开连接，然后修改数据，最后再将所有的修改重新合并回去的情况。一个简单的例子是，一组用户各自在自己的个人电脑上工作，但他们的操作都需要同步到一台主数据库上，然后主数据库会将他们所有人的操作都分发给每个人。实现这个系统需要做两次同步操作。触发器就是构建整个系统的一个好办法。每个人的电脑上都可以使用一个触发器来记录每一次数据的修改，并将其发送到主数据库中。然后，再使用 MySQL的复制将主数据库上的所有操作都复制一份到本地并应用。这里需要额外注意的是，如果触发器基于有自增主键的记录，并且使用的是基于语句的复制，那么自增长可能会在复制中出现不一致。</p><p>有时候可以使用一些技巧绕过触发器是“基于行的触发”这个限制。Roland Bouman 发现对于 BEFORE触发器除了处理的第一条记录，触发器函数 ROW COUNT() 总是会返回1。可以使用这个特点，使得触发器不再是针对每一行都运行，而是针对一条 SQL 语句运行一次。这和真正意义上的单条 SQL 语句的触发器并不相同，不过可以使用这个技术来模拟单条SQL语句的 BEFORE触发器。这个行为可能是 MySQL的一个缺陷，未来版本中可能会被修复，所以在使用这个技巧的时候，需要先验证在你的 MySQL 版本中是否适用另外，在升级数据库的时候还需要检查这类触发器是否还能够正常工作。下面是一个使用这个技巧的例子 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">CREATE TRIGGER fake statement_trigger<br>BEFORE INSERT ON sometable<br>FOR EACH ROW<br>BEGIN<br>    DECLARE v_row_count INT DEFAULT ROW_COUNT();<br>    IF v_row_count &lt;&gt; 1 THEN<br>    -- Your code here<br>    END IF;<br>END;<br></code></pre></td></tr></table></figure><h4 id="7-4-2-1-一个触发器的demo"><a href="#7-4-2-1-一个触发器的demo" class="headerlink" title="7.4.2.1 一个触发器的demo"></a>7.4.2.1 一个触发器的demo</h4><p>在 sakila 数据库中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">--<br>-- Table structure for table `film_text`<br>-- <br>-- InnoDB added FULLTEXT support in 5.6.10. If you use an<br>-- earlier version, then consider upgrading (recommended) or <br>-- changing InnoDB to MyISAM as the film_text engine<br>--<br><br>-- Use InnoDB for film_text as of 5.6.10, MyISAM prior to 5.6.10.<br>SET @old_default_storage_engine = @@default_storage_engine;<br>SET @@default_storage_engine = &#x27;MyISAM&#x27;;<br>/*!50610 SET @@default_storage_engine = &#x27;InnoDB&#x27;*/;<br><br>CREATE TABLE film_text (<br>  film_id SMALLINT NOT NULL,<br>  title VARCHAR(255) NOT NULL,<br>  description TEXT,<br>  PRIMARY KEY  (film_id),<br>  FULLTEXT KEY idx_title_description (title,description)<br>) DEFAULT CHARSET=utf8mb4;<br><br>SET @@default_storage_engine = @old_default_storage_engine;<br><br>--<br>-- Triggers for loading film_text from film<br>--<br><br>DELIMITER ;;<br>CREATE TRIGGER `ins_film` AFTER INSERT ON `film` FOR EACH ROW BEGIN<br>    INSERT INTO film_text (film_id, title, description)<br>        VALUES (new.film_id, new.title, new.description);<br>  END;;<br><br><br>CREATE TRIGGER `upd_film` AFTER UPDATE ON `film` FOR EACH ROW BEGIN<br>    IF (old.title != new.title) OR (old.description != new.description) OR (old.film_id != new.film_id)<br>    THEN<br>        UPDATE film_text<br>            SET title=new.title,<br>                description=new.description,<br>                film_id=new.film_id<br>        WHERE film_id=old.film_id;<br>    END IF;<br>  END;;<br><br><br>CREATE TRIGGER `del_film` AFTER DELETE ON `film` FOR EACH ROW BEGIN<br>    DELETE FROM film_text WHERE film_id = old.film_id;<br>  END;;<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="7-4-3-事件"><a href="#7-4-3-事件" class="headerlink" title="7.4.3 事件"></a>7.4.3 事件</h3><p>事件是 MySQL 5.1引的一种新的存储代码的方式。<strong>它类似于 Linux 的定时任务，不过是完全在 MySQL 内部实现的。你可以创建事件，指定 MySQL 在某个时候执行一段SOL代码，或者每隔一个时间间隔执行一段 SOL代码。</strong>通常，我们会把复杂的 SOL都封装到一个存储过程中，这样事件在执行的时候只需要做一个简单的 CALL调用。</p><p><strong>中间省略了一些不重要的。。。</strong></p><p>还可以在表INFORMATION SCHEMAEVENTS中看到各个事状态，例如这个事件最后一次被执行的时间等。</p><p>类似的，一些适用于存储过程的考虑也同样适用于事件。首先，创建事件意味着给服务器带来额外工作。<strong>事件实现机制本身的开销并不大</strong>，但是事件需要执行 SQL，则可能会对性能有很大的影响。更进一步，事件和其他的存储程序一样，在和基于语句的复制一起工作时，也可能会触发同样的问题。<strong>事件的一些典型应用包括定期地维护任务、重建缓存、构建汇总表来模拟物化视图，或者存储用于监控和诊断的状态值。</strong><br>下面的例子创建了一个事件，它会每周一次针对某个数据库运行一个存储过程 (后面我们将展示如何创建这个存储过程):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">CREATE EVENT optimize somedb ON SCHEDULE EVERY 1 WEEK<br>DO<br>CALL optimize tables(&#x27;somedb&#x27;);<br></code></pre></td></tr></table></figure><p>你可以指定事件本身是否被复制。根据需要，有时需要被复制，有时则不需要。看前面的例子，你可能会希望在所有的备库上都运行 OPTIMIZE TABLE，不过要注意如果所有的备库同时执行，可能会影响服务器的性能 (会对表加锁)。</p><h3 id="7-4-4-在存储程序中保留注释"><a href="#7-4-4-在存储程序中保留注释" class="headerlink" title="7.4.4 在存储程序中保留注释"></a>7.4.4 在存储程序中保留注释</h3><p>存储过程、存储函数、触发器、事件通常都会包含大量的重要代码，在这些代码中加上注释就非常有必要了。但是这些注释可能不会存储在 MySQL 服务器中，因为 MySQL的命令行客户端会自动过滤注释(命令行客户端的这个“特性”令人生厌，不过这就是生活)。</p><h2 id="7-5-游标"><a href="#7-5-游标" class="headerlink" title="7.5 游标"></a>7.5 游标</h2><p>MySQL 在服务器端提供只读的、单向的游标，而且只能在存储过程或者更底层的客户端API中使用。因为 MySQL 游标中指向的对象都是存储在临时表中而不是实际查询到的数据，所以 MySQL 游标总是只读的。它可以逐行指向查询结果，然后让序做进步的处理。在一个存储过程中，可以有多个游标，也可以在循环中“嵌套”地使用游标。</p><p>MySQL 的游标设计也为粗心的人“准备”了陷阱。因为是使用临时表实现的，所以它在效率上给开发人员一个错觉。需要记住的最重要的一点是:当你打开一个游标的时候需要执行整个查询。考虑下面的存储过程:</p><h2 id="7-6-绑定变量"><a href="#7-6-绑定变量" class="headerlink" title="7.6 绑定变量"></a>7.6 绑定变量</h2><p>从MySQL 4.1版本开始，就支持服务器端的绑定变量 (prepared statement)，这大大提高了客户端和服务器端数据传输的效率。你若使用一个支持新协议的客户端，如MySQL C API，就可以使用绑定变量功能了。另外，Java和NET 的也都可以使用各自的客户端Connector&#x2F;J和Connector&#x2F;NET 来使用绑定变量。最后，还有一个SQL接口用于支持绑定变量，后面我们将讨论这个 (这里容易引起困扰)。</p><p>当创建一个绑定变量 SQL时，客户端向服务器发送了一个 SOL语句的原型。服务器端收到这个 SOL语句框架后，解析并存储这个 SOL语句的部分执行计划，返回给客户端一个 SOL 语句处理句柄。以后每次执行这类查询，客户端都指定使用这个句柄.</p><p>绑定变量的 SQL，使用问号标记可以接收参数的位置，当真正需要执行具体查询的时候，则使用具体值代替这些问号。例如，下面是一个绑定变量的 SOL 语句 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">INSERT INTO tbl(col1，col2，col3) VALUES (?，?，?);<br></code></pre></td></tr></table></figure><p>可以通过向服务器端发送各个问号的取值和这个 SOL 的句柄来执行一个具体的查询。反复使用这样的方式执行具体的查询，这正是绑定变量的优势所在。具体如何发送取值参数和SOL句柄，则和各个客户端的编程语言有关。使用Java和NET的MySQL连接器就是一种办法。很多使用MySQL C语言链接库的客户端可以提供类似的接口，需要根据使用的编程语言的文档来了解如何使用绑定变量。</p><p>因为如下的原因，MySQL在使用绑定变量的时候可以更高效地执行大量的重复语句:</p><ul><li><strong>在服务器端只需要解析一次 SQL语句。</strong></li><li><strong>在服务器端某些优化器的工作只需要执行一次，因为它会缓存一部分的执行计划以二进制的方式只发送参数和句柄，比起每次都发送 ASCI码文本效率更高，一个二进制的日期字段只需要三个字节，但如果是 ASCII码则需要十个字节。不过最大的节省还是来自于 BLOB和TEXT字段，绑定变量的形式可以分块传输，而无须一次性传输。二进制协议在客户端也可能节省很多内存，减少了网络开销，另外，还节省了将数据从存储原始格式转换成文本格式的开销。</strong></li><li><strong>仅仅是参数一一而不是整个查询语句一一需要发送到服务器端，所以网络开销会更小。</strong></li><li><strong>MySQL 在存储参数的时候，直接将其存放到缓存中，不再需要在内存中多次复制.</strong></li></ul><p>绑定变量相对也更安全。无须在应用程序中处理转义，一则更简单了，二则也大大减少了SQL 注入和攻击的风险。(任何时候都不要信任用户输入，即使是使用绑定变量的时候。)</p><p>可以只在使用绑定变量的时候才使用二进制传输协议。如果使用普通的 MySQL_query()接口则不会使用二进制传输协议。还有一些客户端让你使用绑定变量，先发送带参数的绑定 SQL，然后发送变量值，但是实际上，这些客户端只是模拟了绑定变量的接口，最后还是会直接用具体值代替参数后，再使用 MySQL query()发送整个查询语句</p><h3 id="7-6-1-绑定变量的优化"><a href="#7-6-1-绑定变量的优化" class="headerlink" title="7.6.1 绑定变量的优化"></a>7.6.1 绑定变量的优化</h3><p>对使用绑定变量的 SQL，MySQL 能够缓存其部分执行计划，如果某些执行计划需要根据传入的参数来计算时，MySQL就无法缓存这部分的执行计划。根据优化器什么时候工作，可以将优化分为三类。在本书编写的时候，下面的三点是适用的。<br>在准备阶段<br>        服务器解析 SQL语句，移除不可能的条件，并且重写子查询。</p><p>在第一次执行的时候<br>        如果可能的话，服务器先简化嵌套循环的关联，并将外关联转化成内关联。</p><p>在每次 SOL 语句执行时<br>服务器做如下事情 :</p><ul><li>过滤分区。</li><li>如果可能的话，尽量移除 COUNT()、MIN()和MAX()。</li><li>移除常数表达式。</li><li>检测常量表。</li><li>做必要的等值传播</li><li>分析和优化ref、range和索引优化等访问数据的方法优化关联顺序。</li></ul><p>参考第 6章，可以了解更多关于这些优化的信息。理论上，有些优化只需要做一次，但实际上，上面的操作还是都会被执行</p><h3 id="7-6-2-SQL接口的绑定变量"><a href="#7-6-2-SQL接口的绑定变量" class="headerlink" title="7.6.2 SQL接口的绑定变量"></a>7.6.2 SQL接口的绑定变量</h3><p>在4.1和更新的版本中，MySQL 支持了SQL接口的定变量。不使用二进制传输协议也可以直接以SOL的方式使用绑定变量。下面案例展示了如何使用SOL接口的绑定变量:</p><img src="/2023/09/27/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%94%E8%AE%B0/image-20230107232028503.png" class=""><h3 id="7-6-3-绑定变量的限制"><a href="#7-6-3-绑定变量的限制" class="headerlink" title="7.6.3 绑定变量的限制"></a>7.6.3 绑定变量的限制</h3><p>关于绑定变量的一些限制和注意事项如下 :</p><ul><li><strong>绑定变量是会话级别的，所以连接之间不能共用绑定变量句柄。</strong>同样地，一旦连接断开，则原来的句柄也不能再使用了。(连接池和持久化连接可以在一定程度上缓解这个问题。)</li><li>在MySQL5.1版本之前，绑定变量的SQL是不能使用查询缓存的</li><li><strong>并不是所有的时候使用绑定变量都能获得更好的性能。如果只是执行一次 SQL，那么使用绑定变量方式无疑比直接执行多了一次额外的准备阶段消耗，而且还需要一次额外的网络开销。</strong>(要正确地使用绑定变量，还需要在使用完成后，释放相关的资源。</li><li>当前版本下，还不能在存储函数中使用绑定变量 (但是存储过程中可以使用)如果总是忘记释放绑定变量资源，则在服务器端很容易发生资源“泄漏”。绑定变量SOL 总数的限制是一个全局限制，所以某一个地方的错误可能会对所有其他的线程都产生影响。</li><li>有些操作，如 BEGIN，无法在绑定变量中完成</li></ul><h2 id="7-7-用户自定义函数"><a href="#7-7-用户自定义函数" class="headerlink" title="7.7 用户自定义函数"></a>7.7 用户自定义函数</h2><p>从很早开始，MySQL 就支持用户自定义函数 (UDF)。存储过程只能使用 SQL 来编写,而<strong>UDF 没有这个限制，你可以使用支持 C语言调用约定的任编程语言来实现。</strong><br>UDF 必须事先编译好并动态链接到服务器上，这种平台相关性使得 UDF 在很多方面都很强大。UDF 速度非常快，而且可以访问大量操作系统的功能，还可以使用大量库函数使用 SOL实现的存储函数在实现一些简单操作上很有优势，诸如计算球体上两点之间的距离，但是如果操作涉及到网络交互，那么只能使用UDF了。同样地，如果需要一个MySQL 不支持的统计聚合函数，而且无法使用 SQL 编写的存储函数来实现的话，通常使用UDF是很容易实现的。<br>能力越大，责任越大。所以在 UDF 中的一个错误很可能会让服务器直接崩溃，甚至扰乱服务器的内存或者数据，另外，所有 C 语言具有的潜在风险，UDF 也都有。</p><h2 id="7-8-插件"><a href="#7-8-插件" class="headerlink" title="7.8 插件"></a>7.8 插件</h2><p>除了UDF，MySQL还支持各种各样的插件。这些插件可以在MySQL 中新增启动选项和状态值，还可以新增<strong>INFORMATION_SCHEMA表，或者在MySQL的后台执行任务</strong>，等等。</p><ul><li>存储过程插件<br>存储过程插件可以帮你在存储过程运行后再处理一次运行结果。这是一个很古老的插件了，和UDF 有些类似，多数人都可能忘记了这个插件的存在。内置的PROCEDUREANALYSE就是一个很好的示例。</li><li>后台插件<br>后台插件可以让你的程序在 MySQL 中运行，可以实现自己的网络监听、执行自己的定期任务。后台插件的一个典型例子就是在 Percona Server 中包含的HandlerSocket 插件。它监听一个新的网络端口，使用一个简单的协议可以帮你无须使用SQL接口直接访问 InnoDB 数据，这也使得MySQL能够像一些NOSOL一样具有非常高的性能。</li></ul><h2 id="7-9-字符集和校对"><a href="#7-9-字符集和校对" class="headerlink" title="7.9 字符集和校对"></a>7.9 字符集和校对</h2><p>字符集是指一种从二进制编码到某类字符符号的映射，可以参考如何使用一个字节来表示英文字母。“校对”是指一组用于某个字符集的排序规则。MySQL4.1 和之后的版本中每一类编码字符都有其对应的字符集和校对规则生。MySQL对各种字符集的支持非常完<br>善，但是这也带来了一定的复杂性，某些场景下甚至会有一定的性能牺牲。(另外，曾经Drizzle 放弃了所有的字符集，所有字符全部统一使用 UTF-8。)</p><h2 id="7-10-全文索引"><a href="#7-10-全文索引" class="headerlink" title="7.10  全文索引"></a>7.10  全文索引</h2><p><strong>全文索引是为了解决需要基于相似度的查询，而不是精确数值比较。</strong></p><p><strong>虽然使用 <code>like + %</code> 也可以实现模糊匹配，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 <code>like</code> 快 N 倍，速度不是一个数量级。</strong></p><p>这里有个网页，介绍概念的 <a href="https://www.cnblogs.com/yangyxd/p/15252691.html">MySQL全文索引</a> </p><p><strong>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询了。但是，如果你希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</strong></p><p>全文索引有着自己独特的语法。没有索引也可以工作，如果有索引效率会更高。用于全文搜索的索引有着独特的结构，帮助这类查询找到匹配某些关键字的记录。</p><p>你可能没有在意过全文索引，不过至少应该对一种全文索引技术比较熟悉:互联网搜索引擎。虽然这类搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理都是一样的。</p><p>全文索引可以支持各种字符内容的搜索 (包括CHARVARCHAR和TEXT类型)，也支持自然语言搜索和布尔搜索。在 MySQL 中全文索引有很多的限制12，其实现也很复杂，但是因为它是 MySQL内置的功能，而且满足很多基本的搜索需求，所以它的应用仍然非常广泛。本章我们将介绍如何使用全文索引，以及如何为应用设计更高性能的全文索引。</p><p>在本书编写时，在标准的MySQL 中，只有 MyISAM引警支持全文索引。不过在还没有正式发布的 MySQL 5.6 中，InnoDB 已经实验性质地支持全文索引了。除此，还有第三方的存储引擎，如 Groonga，也支持全文索引。</p><p>事实上，MyISAM 对全文索引的支持有很多的限制，例如表级别锁对性能的影响、数据文件的崩溃、崩溃后的恢复等，这使得 MyISAM 的全文索引对于很多应用场景并不合适所以，多数情况下我们建议使用别的解决方案，例如 Sphinx、Lucene、Solr、GroongaXapian 或者 Senna，再或者可以等 MySQL 5.6 版本正式发布后，直接使用InnoDB 的全文索引。如果 MyISAM 的全文索引确实能满足应用的需求，那么可以继续阅读本节。</p><p>MyISAM 的全文索引作用对象是一个“全文集合”，这可能是某个数据表的一列，也可能是多个列。具体的，对数据表的某一条记录，MySQL 会将需要索引的列全部拼接成一个字符串，然后进行索引。</p><p>MyISAM的全文索引是一类特殊的 B-Tree 索引，共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的“文档指针”。全文索引不会索引文档对象中的所有词语，它会根据如下规则过滤一些词语。</p><ul><li>停用词列表中的词都不会被索引。默认的停用词根据通用英语的使用来设置，可以使用参数 ft_stopword_fle指定一组外部文件来使</li><li>用自定义的停用词对于长度大于  ft_max_word_len 的词语和长度小于 ft_max_word_len 的词语，都不会被索引。</li></ul><p>全文索引并不会存储关键字具体匹配在哪一列，如果需要根据不同的列来进行组合查询那么不需要针对每一列来建立多个这类索引。<br>这也意味着不能在 MATCH AGAINST子中指定哪个列的相关性更重要。通常构建一个网站的搜索引擎是需要这样的功能，例如，你可能希望优先搜索出那些在标题中出现过的文档对象。如果需要这样的功能，则需要编写更复杂的查询语句。</p><h3 id="7-10-1-自然语言的全文索引"><a href="#7-10-1-自然语言的全文索引" class="headerlink" title="7.10.1 自然语言的全文索引"></a>7.10.1 自然语言的全文索引</h3><p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，配时的相关度就越高。相反，非常常见的单词将不会搜索，即使不在停用词列表中出现，如果一个词语在超过 50% 的记录中都出现了，那么自然语言搜索将不会搜索这类词语。</p><p>全文索引的语法和普通查询略有不同。可以根据 WHERE 子句中的 MATCH AGAINST 来区分查询是否使用全文索引。我们来看一个示例。在标准的数据库 Sakila 中，数据表 filmtext 在字段 title和 description 上建立了全文索引;</p><img src="/2023/09/27/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%94%E8%AE%B0/image-20230108235047219.png" class=""><p>下面是一个使用自然语言搜索的查询 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT<br>film_id,<br>title,<br>RIGHT (description, 25),<br>MATCH (title, description) AGAINST (&#x27;factory casualties&#x27;) AS relevance<br>FROM<br>sakila.film_text<br>WHERE<br>MATCH (title, description) AGAINST (&#x27;factory casualties&#x27;);<br>-- relevance 翻译为关联<br></code></pre></td></tr></table></figure><img src="/2023/09/27/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%94%E8%AE%B0/image-20230108235356912.png" class=""><p><strong>MySQL 将搜索词语分成两个独立的关键词进行搜索，搜索在 title和 description字段组成的全文索引上进行</strong>。注意，只有一条记录同时包含全部的两个关键词，有三个查询结果只包含关键字 “casualties” (这是整个表中仅有的三条包含该关键词的记录)，这三个结果都在结果列表的前面。这是因为查询结果是根据与关键词的相似度来进行排序的。</p><p>和普通查询不同，这类查询自动按照相似度进行排序。在使用全文索引进行排序的时候，MySQL 无法再使用索引排序。所以如果不想使用文件排序的话，那么就不要在查询中使用ORDER BY子句。</p><p>从上面的示例可以看到，函数 MATCH() 将返回关键词匹配的相关度，是一个浮点数字。你可以根据相关度进行匹配，或者将此直接展现给用户。在一个查询中使用两次MATCH()函数并不会有额外的消耗，MSOL 会自动识别并只进行一次搜索。不过，如果你将MATCH()函数放到ORDER BY子中，MySQL将会使用文件排序.</p><p>在MATCH()函数中指定的列必须和在全文索引中指定的列完全相同，否则就无法使用全文索引。这是因为全文索引不会记录关键字是来自哪一列的。</p><p>这也意味着无法使用全文索引来查询某个关键字是否在某一列中存在。这里介绍一个绕过该问题的办法:根据关键词在多个不同列的全文索引上的相关度来算出排名值，然后依此来排序。我们可以在某一列上加上如下索 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">ALTER TABLE film_text ADD FULLTEXT KEY(title);<br></code></pre></td></tr></table></figure><p>这样，我们可以将 title 匹配乘以 2 来提高它的相似度的权重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT<br>film_id,<br>RIGHT (description, 25), <br>ROUND(MATCH(title, description) AGAINST (&#x27;factory casualties&#x27;), 3 ) AS full_rel,<br>ROUND( MATCH (title) AGAINST (&#x27;factory casualties&#x27;), 3 ) AS title_rel<br>FROM<br>sakila.film_text<br>WHERE<br>MATCH (title, description) AGAINST (&#x27;factory casualties&#x27;)<br>ORDER BY<br>(<br>2 * MATCH (title) AGAINST (&#x27;factory casualties&#x27;)<br>) + MATCH (title, description) AGAINST (&#x27;factory casualties&#x27;) DESC;<br></code></pre></td></tr></table></figure><p>因为上面的查询需要做文件排序，所以这并不是一个高效的做法</p><h2 id="7-11-分布式-XA-事务"><a href="#7-11-分布式-XA-事务" class="headerlink" title="7.11 分布式(XA)事务"></a>7.11 分布式(XA)事务</h2><p><strong>存储引擎的事务特性能够保证在存储引擎级别实现ACID(参考前面介绍的“事务”</strong>.而分布式事务则让存储引擎级别的 ACID 可以扩展到数据库层面，甚至可以扩展到多个数据库之间一一这需要通过两阶段提交实现。MySQL 5.0和更新版本的数据库已经开始支持 XA 事务了。<br>XA 事务中需要有一个事务协调器来保证所有的事务参与者都完成了准备工作 (第一阶段)。如果协调器收到所有的参与者都准备好的消息，就会告诉所有的事务可以提交了这是第二阶段。MySQL 在这个 XA 事务过程中扮演一个参与者的角色，而不是协调者。</p><p>实际上，在MySQL中有两种XA 事务。一方面，MySQL 可以参与到外部的分布式事务中，另一方面，还可以通过 XA 事务来协调存储引擎和二进制日志。</p><h2 id="7-12查询缓存"><a href="#7-12查询缓存" class="headerlink" title="7.12查询缓存"></a>7.12查询缓存</h2><p><strong>注： 主要围绕着 “缓存完整的 SELECT查询结果” 这点来说论述</strong></p><p>很多数据库产品都能够<strong>缓存查询的执行计划</strong>，对于相同类型的 SQL就可以跳过 SQL解析和执行计划生成阶段。MySQL 在某些场景下也可以实现，但是 <strong>MySQL 还有另一种不同的缓存类型:，也就是“查询存”</strong>。本节将详细介绍这类缓存。</p><p><strong>MySQL查询缓存保存查询返回的完整结果。当查询命中该缓存MySQL会立刻返回结果跳过了解析、优化和执行阶段。</strong></p><p>【这里考虑，计算 sql预计hash值，然后作为key，sql结果作为值】</p><p><strong>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失效。这种机制效率看起来比较低，因为数据表变化时很有可能对应的查询结果并没有变更，但是这种简单实现代价很小，而这点对于一个非常繁忙的系统来说非常重要。</strong> 【<strong>论述具体实现</strong>】</p><p><strong>查询缓存对应用程序是完全透明的。应用程序无须关心 MySQL 是通过查询缓存返回的结果还是实际执行返回的结果。</strong>事实上,这两种方式执行的结果是完全相同的。换句话说查询缓存无须使用任何语法。无论是 MySOL 开启或关闭查询缓存，对应用程序都是透的。</p><p>随着现在的通用服务器越来越强大，查询缓存被发现是一个影响服务器扩展性的因素它可能成为整个服务器的资源竞争单点，在多核服务器上还可能导致服务器僵死。后面我们将详细介绍如何配合查询缓存，但是很多时候我们还是认为应该默认关闭查询缓存如果查询缓存作用很大的话，那就配置一个很小的查询缓存空间(如几十兆)。后面我们将解释如何判断在你的系统压力下打开查询缓存是否有好处。</p><h3 id="7-12-1-MySQL如何判断缓存命中"><a href="#7-12-1-MySQL如何判断缓存命中" class="headerlink" title="7.12.1 MySQL如何判断缓存命中"></a>7.12.1 MySQL如何判断缓存命中</h3><p>MySQL 判断缓存命中的方法很简单: <strong>缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了如下因素，即查询本身、当前要查询的数据库</strong>、客户端协议的版本等些其他可能会影响返回结果的信息。</p><p>当判断缓存是否命中时，MySQL 不会解析、“正规化”或者参数化查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。<strong>任何字符上的不同，例如空格、注释一一任何的不同一一都会导致缓存的不命中</strong>。所以在编写 SOL 语的时候，需要特别注意这点。通常使用统一的编码规则是一个好的习惯，在这里这个好习惯会让你的系统运行得更快。</p><p><strong>当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数 NOW()或者 CURRENTDATE()的查询不会被缓存。</strong>类似的，包含 CURRENT USER 或者 CONNECTION ID()的查询语句因为会根据不同的用户返回不同的结果，所以也不会被缓存。事实上，如果查询中包含任何<strong>用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，或者任何包含列级别权限的表，都不会被缓存。</strong>【如果想知道所有情况，建议阅读 MySOL官方手册。】</p><p>我们常听到 :“如果查询中包含一个不确定的函数，MySQL 则不会检查查询缓存”。这个说法是不正确的。因为<strong>在检查查询缓存的时候，还没有解析 SOL语句，所以MySOL并不知道查询语句中是否包含这类函数。</strong>在检查查询缓存之前，MySQL 只做一件事情就是通过一个大小写不敏感的检查看看 SQL语是不是以 SEL开头。</p><p><strong>准确的说法应该是:“如果查询语句中包含任何的不确定函数，那么在查询缓存中是不可能找到缓存结果的”。因为即使之前刚刚执行了这样的查询,结果也不会放在查询缓存中.MySQL在任何时候只要发现不能被缓存的部分，就会禁止这个查询被缓存。</strong></p><p>所以，如果希望换成一个带日期的查询，那么最好将日期提前计算好，而不要直接使用函数。例如 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">... DATE SUB(CURRENT DATE，INTERVAL 1 DAY) ...  -- Not cacheable!<br>... DATE SUB(&#x27;2007-07-14’,INTERVAL 1 DAY)  ...  -- Cacheable...<br></code></pre></td></tr></table></figure><p>因为查询缓存是在完整的 SELECT 语基础上的，而且只是在刚收到 SQL 语的时候才检查，所以子查询和存储过程都没办法使用查询缓存。在MySQL 5.1之前的版本中绑定变量也无法使用查询缓存。</p><p>MySQL的查询缓存在很多时候可以提升查询性能，在使用的时候，有一些问题需要特别注意。首先，<strong>打开查询缓存对读和写操作都会带来额外的消耗</strong> :</p><ul><li>读查询在开始之前必须先检查是否命中缓存.</li><li>如果这个读查询可以被缓存，那么当完成执行后，MySQL 若发现查询缓存中没有这个查询，会将其结果存入查询缓存，这会带来额外的系统消耗。</li><li>这对写操作也会有影响，因为当向某个表写入数据的时候，MySOL 必须将对应表的所有缓存都设置失效。如果查询缓存非常大或者碎片很多，这个操作就可能会带来很大系统消耗(设置了很多的内存给查询缓存用的时候)。</li></ul><p>虽然如此，查询缓存仍然可能给系统带来性能提升。但是，如上所述，这些额外消耗也可能不断增加，再加上对查询缓存操作是一个加锁排他操作，这个消耗可能不容小觑。</p><p>对InnoDB 用户来说，事务的一些特性会限制查询缓存的使用。当一个语句在事务中修改了某个表，MySQL 会将这个表的对应的查询缓存都设置失效，而事实上，InnoDB的多版本特性会暂时将这个修改对其他事务屏蔽。在这个事务提交之前，这个表的相关查询是无法被缓存的，所以所有在这个表上面的查询一一内部或外部的事务一一都只能在该事务提交后才被缓存。<strong>因此，长时间运行的事务，会大大降低查询缓存的命中率。</strong></p><p>如果查询缓存使用了很大量的内存，缓存失效操作就可能成为一个非常严重的问题瓶颈。<strong>如果缓存中存放了大量的查询结果，那么缓存失效操作时整个系统都可能会僵死一会儿。因为这个操作是靠一个全局锁操作保护的，所有需要做该操作的查询都要等待这个锁，而且无论是检测是否命中缓存、还是缓存失效检测都需要等待这个全局锁。</strong>第 3 章中有一个真实的案例，为大家展示查询缓存过大时带来的系统消耗。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>笔记</tag>
      
      <tag>高性能MySQL第三版笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manage data in Docker</title>
    <link href="/2023/09/21/Manage%20data%20in%20Docker/"/>
    <url>/2023/09/21/Manage%20data%20in%20Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Manage-data-in-Docker"><a href="#Manage-data-in-Docker" class="headerlink" title="Manage data in Docker"></a>Manage data in Docker</h1><p>Docker has two options for containers to store files on the host machine, so that the files are persisted even after the container stops: <em>volumes</em>, and <em>bind mounts</em>.</p><p>Docker also supports containers storing files in-memory on the host machine. Such files are not persisted. </p><h2 id="Choose-the-right-type-of-mount"><a href="#Choose-the-right-type-of-mount" class="headerlink" title="Choose the right type of mount"></a><a href="https://docs.docker.com/storage/#choose-the-right-type-of-mount">Choose the right type of mount</a></h2><p>An easy way to visualize the difference among volumes, bind mounts, and <code>tmpfs</code> mounts is to <strong>think about where the data lives on the Docker host</strong>.</p><p><img src="https://docs.docker.com/storage/images/types-of-mounts.png" alt="Types of mounts and where they live on the Docker host"></p><ul><li><strong>Volumes</strong> are stored in a part of the host filesystem which is <em>managed by Docker</em> (<code>/var/lib/docker/volumes/</code> on Linux). <strong>Non-Docker processes should not modify this part of the filesystem.</strong> Volumes are the best way to persist data in Docker.</li><li><strong>Bind mounts</strong> may be stored <em>anywhere</em> on the host system. They may even be important system files or directories. Non-Docker processes on the Docker host or a Docker container can modify them at any time.</li><li><strong><code>tmpfs</code> mounts</strong> are stored in the host system’s memory only, and are never written to the host system’s filesystem.</li></ul><p>to be continue</p><p><a href="https://docs.docker.com/storage/">https://docs.docker.com/storage/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Manage data in Docker</tag>
      
      <tag>Docker官网摘要</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis设计与实践读书笔记</title>
    <link href="/2023/09/21/blog-post2/"/>
    <url>/2023/09/21/blog-post2/</url>
    
    <content type="html"><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>redis内部数据结构详解,  适合看看大概实现和为什么要这样实现</p><p><a href="https://cloud.tencent.com/developer/article/2220233">https://cloud.tencent.com/developer/article/2220233</a></p><h1 id="第一章-序言"><a href="#第一章-序言" class="headerlink" title="第一章 序言"></a>第一章 序言</h1><h2 id="1-3-推荐的阅读方法"><a href="#1-3-推荐的阅读方法" class="headerlink" title="1.3 推荐的阅读方法"></a>1.3 推荐的阅读方法</h2><img src="/2023/09/21/blog-post2/image-20230211220332240.png" class=""><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h1 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h1><p>第2章 简单动态字符串</p><p>第3章 链表</p><p>第4章 字典</p><p>第5章 跳跃表</p><p>第6章 数集合</p><p>第7章 压缩列表</p><p>第8章 对象</p><h1 id="第2章简-简单动态字符串"><a href="#第2章简-简单动态字符串" class="headerlink" title="第2章简 简单动态字符串"></a>第2章简 简单动态字符串</h1><p>​Redis 没有直接使用 C 语言传统的字符串表示(以空字符 ‘\0’ 结尾的字符数组，以下简称C字符串)，而是自己构建了一种名为简单动态字符(simple dynamic string，SDS)的抽象类型，并将 SDS 用作 Redis 的默认字符串表示。</p><p>​在 Redis 里面，C字符只会作为字符字面量(string literal)用在一些无须对字符串值进行修改的地方，比如打印日志:</p><p>​当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符值，比如在 Redis 的数据里面，包含字符值的键值对在底层都是由SDS实现的。</p><p>举个例子，如果客户端执行命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis&gt; SET msg <span class="hljs-string">&quot;hello world&quot;</span><br>OK<br></code></pre></td></tr></table></figure><p>那么 Redis 将在数据库中创建一个新的键值对，其中:</p><ul><li>键值对的键是一个字符对象，对象的底层实现是一个保存着字符“msg”的 SDS.</li><li>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串”he11oworld”的SDS.</li></ul><p>除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区(buffer):AOF 模块中的AOF 缓冲区，以及客户端状态中的输人缓冲区，都是由 SDS 实现的，在之后介绍AOF持久化和客户端状态的时候，我们会看到 SDS 在这两个模块中的应用。</p><h2 id="2-1-SDS的定义"><a href="#2-1-SDS的定义" class="headerlink" title="2.1 SDS的定义"></a>2.1 SDS的定义</h2><p>每个 sds.h&#x2F;sdshdr 结构表示一个SDS 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span>&#123;</span><br>    <span class="hljs-comment">//记录 buf 数组中已使用字节的数量</span><br>    <span class="hljs-comment">// 等于 SDS 所保存字符串的长度</span><br><span class="hljs-type">int</span> len;<br><span class="hljs-comment">// 记录 buf 数组中未使用字节的数量</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br><span class="hljs-comment">// 字节数组，用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[l;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/09/21/blog-post2/image-20230211222430273.png" class=""><ul><li>free 属性的值为 0，表示这个 SDS 没有分配任何使用空间</li><li>len 属性的值为 5，表示这个 SDS 保存了一个五字节长的字符</li><li>buf属性是一个char类型的数组，数组的前五个字节分别保存了 ‘R’, ‘e’, ‘d’, ‘i’、’s，五个字符，而最后一个字节则保存了空字符’\0’</li></ul><p>​SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在 SDS的len 属性里面，并且为空字符分配额外的 1字节空间，以及添加空字符到字符申末尾等操作，都是由 SDS 函数自动完成的，所以这个空字符对于SDS 的使用者来说是完全透明的遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分C 符串函数库里面的函数.</p><img src="/2023/09/21/blog-post2/image-20230211223052325.png" class=""><p>图2-2展示了另一个SDS示例。这个SDS 和之前展示的SDS一样，都保存了字符串值”Redis”。这个SDS 和之前展示的SDS的区别在于，这个SDS 为buf 数组分配了五字节未使用空间，所以它的 free  的值为 5(图中使用五个空格来表示五字节的未使用空间)。</p><h2 id="2-2-SDS与C字符串的区别"><a href="#2-2-SDS与C字符串的区别" class="headerlink" title="2.2  SDS与C字符串的区别"></a>2.2  SDS与C字符串的区别</h2><p>根据传统，C 语言使用长度为 N+1 的字符数组来表示长度为N的字符，并且字符数组的最后一个元素总是空字符 ‘\0’</p><img src="/2023/09/21/blog-post2/image-20230211223342128.png" class=""><p>例如，图2-3 就展示了一个值为“Redis”的C字符串</p><p>C语言使用的这种简单的字符申表示方式，并不能满足 Redis 对字符申在安全性、效率以及功能方面的要求，本节接下来的内容将详细对比C字符串和SDS之间的区别，并说明 SDS比C字符申更适用于 Redis 的原因</p><h3 id="2-2-1-常数复杂度获取字符串长度"><a href="#2-2-1-常数复杂度获取字符串长度" class="headerlink" title="2.2.1 常数复杂度获取字符串长度"></a>2.2.1 常数复杂度获取字符串长度</h3><p>​因为 C字符串并不记录自身的长度信息，所以为了获取一个 C 字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为 O(N)。</p><img src="/2023/09/21/blog-post2/image-20230211223620606.png" class=""><p>​举个例子，图 2-4 展示了程序计算一个 C字符串长度的过程。</p><p>​和C字符串不同，因为SDS在len 属性中记录了 SDS 本身的长度，所以获取一个 SDS长的复杂度仅 0(1)。</p><img src="/2023/09/21/blog-post2/image-20230211223643826.png" class="">举个例子，对于图2-5 所示的SDS来说，程序只要访问 SDS的 len 属性，就可以立即知道SDS的长度为5字节。<pre><code class="hljs">又例如，对于图 2-6 展示的SDS 来说，程序只要访问 SDS的 len 属性，就可以立即知道SDS的长度为11字节。</code></pre><p>设置和更新SDS长度的工作是由 SDS的API在执行时自动完成的，使用SDS 无须进行任何手动修改长度的工作。</p><h3 id="2-2-2-杜绝缓冲区溢出"><a href="#2-2-2-杜绝缓冲区溢出" class="headerlink" title="2.2.2 杜绝缓冲区溢出"></a>2.2.2 杜绝缓冲区溢出</h3><p>​除了获取字符串长度的复杂度高之外，C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出(bufer overow)。举个例子，&lt;string.h&gt;&#x2F;strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span><br></code></pre></td></tr></table></figure><p>​因为C字符串不记录自身的长度，所以 strcat 假定用户在执行这个函数时，已经为dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。<br>​举个例子，假设程序里有两个在内存中紧邻着的C字符 s1 和 s2，其s1保存了符串“Redis”，而 s2 则保存了字符串“MongoDB”，如图2-7所。</p><img src="/2023/09/21/blog-post2/image-20230211224051133.png" class=""><p>如果一个程序员决定通过执行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">strcat</span>(s1, <span class="hljs-string">&quot; Cluster&quot;</span>);<br></code></pre></td></tr></table></figure><p>​将s1的内容修改为”Redis cluster”，但粗心的他却忘了在执行 strcat 之前为s1分配足够的空间，那么在 strcat 函数执行之后，s1 的数据将溢出到 s2 所在的空间中导致 s2 保存的内容被意外地修改，如图 2-8 所示。</p><img src="/2023/09/21/blog-post2/image-20230211224227549.png" class=""><p>​与C字符串不同，SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当SDSAPI需要对SDS进行修时，API会先检SDS 的间是否所的求，如果不满足的话，API会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区出问题。</p><img src="/2023/09/21/blog-post2/image-20230211224508728.png" class=""><img src="/2023/09/21/blog-post2/image-20230211224523733.png" class=""><h3 id="2-23-减少修改字符串时带来的内存重分配次数"><a href="#2-23-减少修改字符串时带来的内存重分配次数" class="headerlink" title="2.23 减少修改字符串时带来的内存重分配次数"></a>2.23 减少修改字符串时带来的内存重分配次数</h3><p>​因为 C 字符串并不记录自身的长度，所以对于一个包含了 N个字符的 C字符串来说，这个 C 字符的底层实现总是一个 N1个字符长的数组(额外的个字符空间用于保存空字符)。因为 C字符的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个 C字符串，序都总要对保存这个 C字符的数组进行一次内存重分配操作</p><ul><li>如果序执行的是增长字符的操作，比如拼接操作 (append)，那么在执行这个作之前，程序需要先通过内存重分配来扩展底层数组的空间大小一一如果忘了这一步就会产生缓冲区溢出。</li><li>如果程序执行的是缩短字符的操作，比如截断操作(trim)那在行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间一-如果忘了这一步就会产生内存泄漏。</li></ul><p>因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作:</p><ul><li>在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的。</li><li>但是 Redis 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话可能还会对性能造成影响。</li></ul><p>​为了避免 C 字符串的这种缺陷，SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联: 在 SDS 中，buf 数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由 SDS的 free 属性记录。</p><p>通过未使用空间<strong>，SDS实现了空间预分配和惰性空间释放两种优化策略</strong></p><p><strong>1.空间预分配</strong></p><p>​空间预分配用于优化SDS 的字符串增长操作:当SDS的API对一个SDS进行修改并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，还会为SDS分配额外的未使用空间。</p><p><strong>2.性空间释放</strong></p><p>​惰性空间释放用于优化 SDS 的字符申缩短操作:当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。</p><h3 id="2-2-4-二进制安全"><a href="#2-2-4-二进制安全" class="headerlink" title="2.2.4 二进制安全"></a>2.2.4 二进制安全</h3><p>​C 字符串中的字符必须符合某种编码(比如ASCI)，并且除了字符的末尾之外符串里面不能包含空字符，否则最先被程序读人的空字符将被误认为是字符申结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。<br>​举个例子，如果有一种使用空字符来分割多个单词的特殊数据格式，如图2-17 所示那么这种格式就不能使用C字符串来保存，因为 C字符串所用的函数只会识别出其中的 “Redis”，而忽略之后的“Cluster”。</p><img src="/2023/09/21/blog-post2/image-20230211225807862.png" class=""><img src="/2023/09/21/blog-post2/image-20230211225905066.png" class=""><h3 id="2-2-5-兼容部分C字符串函数"><a href="#2-2-5-兼容部分C字符串函数" class="headerlink" title="2.2.5 兼容部分C字符串函数"></a>2.2.5 兼容部分C字符串函数</h3><p>​虽然SDS的API都是二进制安全的，但它们一样遵循C字符以空字符结尾的惯例这些API总会将 SDS 保存的数据的末尾设置为空字符，并且总会在为 buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分&lt;string.h&gt;库定义的函数。</p><img src="/2023/09/21/blog-post2/image-20230211225948427.png" class=""><h3 id="2-2-6-总结"><a href="#2-2-6-总结" class="headerlink" title="2.2.6 总结"></a>2.2.6 总结</h3><p>表2-1对C字符串和SDS 之间的区别进行了总结</p><img src="/2023/09/21/blog-post2/image-20230211230055837.png" class=""><img src="/2023/09/21/blog-post2/image-20230211230113459.png" class=""><h2 id="2-4-重点回顾"><a href="#2-4-重点回顾" class="headerlink" title="2.4 重点回顾"></a>2.4 重点回顾</h2><ul><li>Redis 只会使用C字符申作为字面量，在大多数情况下，Redis 使用SDS(SimpleDynamic String，简单动态字符串)作为字符串表示。</li><li>比起C字符串，SDS 具有以下优点:</li></ul><ol><li>常数复杂度取符度</li><li>杜绝缓冲区溢出</li><li>减少修字符长度时所需的内存重分配次数</li><li>二制安全</li><li>兼容部分C符函</li></ol><h1 id="第3章-表链"><a href="#第3章-表链" class="headerlink" title="第3章 表链"></a>第3章 表链</h1><p>​<strong>链表</strong>提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。</p><p>​作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为 Redis 使用的C语言并没有内置这种数据结构，所以 Redis 构建了自己的链表实现。</p><p>​链表在 Redis 中的应用非常广泛，比如<strong>列表键</strong>的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。</p><p>​<strong>除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表</strong>，Redis 服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区(output buffer)本书后续的章节将陆续对这些链表应用进行介绍。</p><h2 id="3-1-链表和链表节点的实现"><a href="#3-1-链表和链表节点的实现" class="headerlink" title="3.1 链表和链表节点的实现"></a>3.1 链表和链表节点的实现</h2><p>每个链表节点使用一个 <code>adlist.h/listnode</code> 结构来表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-comment">// 前置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-comment">// 后置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">// 节点的值    这里 void * 是可以指向任意类型的指针</span><br>    <span class="hljs-type">void</span> *value;<br>&#125;<br>listNode;<br></code></pre></td></tr></table></figure><p>多个listNode可以通过 prev 和 next 指针组成双端链表，如图3-1所示</p><img src="/2023/09/21/blog-post2/image-20230212214758860.png" class=""><p>虽然仅仅使用多个 listNode 结构就可以组成链表，但使用adlisth&#x2F;list 来持有链表的话，操作起来会更方便:</p><p>(<img src="/2023/09/21/blog-post2/image-20230212220215477.png" class=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title function_">list</span> <span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-comment">// 表头节点</span></span><br><span class="hljs-params">    listNode *head;</span><br><span class="hljs-params"><span class="hljs-comment">// 尾节点</span></span><br><span class="hljs-params">listNode *tail;</span><br><span class="hljs-params"><span class="hljs-comment">// 链表所包含的节点数量</span></span><br><span class="hljs-params">    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> lenj</span><br><span class="hljs-params"><span class="hljs-comment">//节点值复制函数</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);</span><br><span class="hljs-params"><span class="hljs-comment">// 节点值释放函数</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);</span><br><span class="hljs-params"><span class="hljs-comment">// 节点值对比函数</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span> *ptr,<span class="hljs-type">void</span> *key);</span><br><span class="hljs-params">&#125; <span class="hljs-built_in">list</span>;</span><br></code></pre></td></tr></table></figure><p>​list 结构为链表提供了表头指针 head、表尾指针 tai，以及链表长度计数器 len, 而 dup、free 和 match 成员则是用于实现多态链表所需的类型特定函数:</p><ul><li>dup函数用于复制链表节点所保存的值</li><li>free函数用于释放链表节点所保存的值</li><li>match 函数则用于对比链表节点所保存的值和另一个输人值是否相等</li></ul><img src="/2023/09/21/blog-post2/image-20230212221946379.png" class=""><p>Redis 的链表实现的特性可以总结如下</p><ul><li>双端:链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的复杂度都是 0(1)</li><li>无环:表头节点的prev 指针和表尾节点的next 指针都向NULL，对链表的访0问以NULL 为终点</li><li>带表头指针和表尾指针:通过 list 结构的  head  指针和  tail  指针，程序获取链表的表头节点和表尾节点的复杂度为 O(1)</li><li>带链表长度计数器:序使用list 结的 len属来对1st 持有的链表节点进行计数，程序获取链表中节点数量的复杂度为 O(1)</li><li>多态:链表节点使用void* 指针来保存节点值，并且可以通过 list 结构的 dupfree、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</li></ul><h2 id="3-2-链表和链表节点的API"><a href="#3-2-链表和链表节点的API" class="headerlink" title="3.2 链表和链表节点的API"></a>3.2 链表和链表节点的API</h2><img src="/2023/09/21/blog-post2/image-20230212222245393.png" class=""><img src="/2023/09/21/blog-post2/image-202302122223082202.png" class=""><h2 id="3-3-重点回顾"><a href="#3-3-重点回顾" class="headerlink" title="3.3 重点回顾"></a>3.3 重点回顾</h2><ul><li>链表被广泛用于实现 Redis 的各种功能，比如列表键、发布与订阅、慢查询、监视器等</li><li>每个链表节点由一个listNode 结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以 Redis 的链表实现是双端链表。</li><li>每个链表使用一个 list 结构来表示，这个结构带有表头节点指针、表尾节点指针以及链表长度等信息</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL，所以 Redis 的链表实现是无环链表</li><li>通过为链表设置不同的类型特定函数，Redis 的链表可以用于保存各种不同类型的值</li></ul><h1 id="第4章-字典"><a href="#第4章-字典" class="headerlink" title="第4章 字典"></a>第4章 字典</h1><p>​字典，又称为符号表(symbol table)关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。在字典中，一个键 (key)可以一个值 (value) 进行关联(说将键为值)这些关联的键和值就称为键值对。</p><p>​字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对，等等。</p><p>​字典经常作为一种数据结构内置在很多高级编语言里面， Redis 所使用的C语言并没有内置这种数据结构，因此 Redis 构建了自己的字典实现。</p><p>​字典在 Redis 中的应用相当广泛，比如 Redis 的数据就是使用字典来作为底层实现的对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p><p>举个例子，当我们执行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">SET msg <span class="hljs-string">&quot;hello world&quot;</span></span><br>OK<br></code></pre></td></tr></table></figure><p>​在数据库中创建一个键为“msg”，值为“hello world”的键值对时，这个键值对就是保存在代表数据库的字典里面的。</p><p>​除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis 就会使用字典作为哈希键的底层实现。</p><h2 id="4-1-字典的实现（重点重点）"><a href="#4-1-字典的实现（重点重点）" class="headerlink" title="4.1 字典的实现（重点重点）"></a><strong>4.1 字典的实现（重点重点）</strong></h2><p>​<strong>4.1全是重点</strong></p><p>​Redis 的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="4-1-1-哈希表（重点重点）"><a href="#4-1-1-哈希表（重点重点）" class="headerlink" title="4.1.1 哈希表（重点重点）"></a>4.1.1 哈希表（重点重点）</h3><p>​Redis 字典所使用的哈希表由 dict.h&#x2F;dictht 结构定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br><span class="hljs-comment">// 哈希表数组, 这是一个二维数组</span><br>    dictEntry **table;<br><span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br><span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-comment">//总是等于size-1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br><span class="hljs-comment">// 该哈希表已有节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>) dictht;<br></code></pre></td></tr></table></figure><p>​<code>table</code> 属性是一个数组，数组中的每个元素都是一个指向 dict.h&#x2F;dictEntry 结构的指针，每个 <code>dictEntry</code> 结构保存着一个键值对。size 属性记录了哈希表的大小，也即是 table 数组的大小，而 used 属性则记录了哈希表目前已有节点(键值对)的数量。sizemask 属性的值总是等于 <code>size-1</code>，这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。图 4-1 展示了一个大小为4的空哈希表没有包含任何键值对)</p><img src="/2023/09/21/blog-post2/image-20230213221641425.png" class=""><h3 id="4-1-2-哈希表节点"><a href="#4-1-2-哈希表节点" class="headerlink" title="4.1.2 哈希表节点"></a>4.1.2 哈希表节点</h3><p>​哈希表节点使用 dictEntry 结构表示，<strong>每个 dictEntry 结构都保存着一个键值对</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-comment">// 键,   void * 是可以指向任意类型的指针</span><br>    <span class="hljs-type">void</span> *key;<br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<br>        uint64_tu64;<br>        int64_ts64;<br>    &#125; v;    <span class="hljs-comment">//  v 只存 三种数据中对的一种</span><br><span class="hljs-comment">// 指向下个哈希表节点，形成链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125; dictEntry;<br><br><span class="hljs-comment">// 联合（union）是一种数据类型，它能在同一个内存空间中储存不同的</span><br><span class="hljs-comment">// 数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规</span><br><span class="hljs-comment">// 律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大</span><br><span class="hljs-comment">// 小相等，每个联合可以储存各种数据类型。</span><br></code></pre></td></tr></table></figure><p><strong>key属性保存着键值对中的键，而v 属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个 uint64_t 整数，又或者是一个 uint64_t 整数。next 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突(collision)的问题。举个例子，图4-2就展示了如何通过 next 指针，将两个索引值相同的键 k1和k0连接在一起。</strong></p><p>注：  k1 和 k0 这两个计算出了相同 hash值，相同的key放到同一个 hash 哈希表节点</p><img src="/2023/09/21/blog-post2/image-20230213223411514.png" class=""><h3 id="4-1-3-字典"><a href="#4-1-3-字典" class="headerlink" title="4.1.3 字典"></a>4.1.3 字典</h3><p>​Redis 中的字典由 dict.h&#x2F;dict 结构表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span>&#123;</span><br>    <span class="hljs-comment">// 类型特定函数</span><br>dictType *type;<br>    <br><span class="hljs-comment">// 私有数据</span><br><span class="hljs-type">void</span> *privdata;<br>    <br><span class="hljs-comment">// 哈希表</span><br>dictht ht[<span class="hljs-number">2</span>];<br>              <br><span class="hljs-comment">// rehash 索引</span><br><span class="hljs-comment">//当 rehash 不在进行时，值为 -1</span><br>in trehashidx; <span class="hljs-comment">/*rehashing not in progress if rehashidx == -1 */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p><strong>type 属性和 privdata 属性是针对不同类型的键值对，为创建多态字典而设置的:</strong></p><ul><li>type 属性是一个指向 dictType 结构的指针，每个 dictType 结构保存了一簇用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同的类型特定函数</li><li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span><br>    <span class="hljs-comment">// 计算哈希值的函数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*hashFunction)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span>;<br>    <span class="hljs-comment">// 复制键的函数</span><br>    <span class="hljs-type">void</span> *(*keyDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">//复制值的函数</span><br>    <span class="hljs-type">void</span> *(*valDup)(<span class="hljs-type">void</span> *privdata， <span class="hljs-type">const</span> <span class="hljs-type">void</span> *obj);<br>    <span class="hljs-comment">// 对比键的函数</span><br>    <span class="hljs-type">int</span> (*keyCompare)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *keyl, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);<br>    <span class="hljs-comment">// 销毁键的函数</span><br>    <span class="hljs-type">void</span> (*keyDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">// 销毁值的函数</span><br>    <span class="hljs-type">void</span> (*valDestructor)(<span class="hljs-type">void</span> .privdata, <span class="hljs-type">void</span> *obj);<br>&#125; dictType;<br></code></pre></td></tr></table></figure><p>​<strong>ht 属性是一个包含两个项的数组，数组中的每个项都是一个 dictht 哈希表，一般情况字典只使用 ht[O] 哈希表，ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用下。</strong></p><p>​除了ht[1]之外，另一个和 rehash有关的属性就是 rehashidx，它记录了rehash 目前的进度，如果目前没有在进行 rehash，那么它的值为 -1。</p><p>图 4-3 展示了一个普通状态下(没有进行 rehash)的字典</p><img src="/2023/09/21/blog-post2/image-20230213225016435.png" class=""><h2 id="4-2-哈希算法"><a href="#4-2-哈希算法" class="headerlink" title="4.2 哈希算法"></a>4.2 哈希算法</h2><p>​当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>Redis 计算哈希值和索引值的方法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"># 使用字典设置的哈希函数，计算键 key 的哈希值<br>hash = dict-&gt;type-&gt;hashFunction(key);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值<br># 根据情况不同，ht[x] 可以是 ht[<span class="hljs-number">0</span>] 或者 ht[<span class="hljs-number">1</span>]<br>index = hash &amp; dict-&gt;ht[x].sizemask;<br></code></pre></td></tr></table></figure><img src="/2023/09/21/blog-post2/image-20230214210606289.png" class=""><p>举个例子，对于图 4-4 所示的字典来说，如果我们要将一个键值对 k0 和 v0 添加到字典里面，那么程序会先使用语句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hash = dict-&gt;type-&gt;hashFunction(k0);<br></code></pre></td></tr></table></figure><p>计算键 k0的哈希值, 假设计算得出的哈希值为 8，那么程序会继续使用语句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">index = hash &amp; dict-&gt;ht[<span class="hljs-number">0</span>].sizemask = <span class="hljs-number">8</span> &amp; <span class="hljs-number">3</span> = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>计算出键 k0 的索引值 0，<strong>这表示含键值对 k0 和 v0 的节点应该被放置到哈表数组的索引0位置上</strong>，如图4-5 所示。</p><img src="/2023/09/21/blog-post2/image-20230214214308217.png" class=""><p>​当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。<br>MurmurHash算法最初由 Austin Appleby 于2008年发明，这种算法的优点在于，即使输人的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。MurmurHash算法目前的最新版本为MurmurHash3，而Redis使用的是 MurmurHash2，关于MurmurHash算法的更多信息可以参考该算法的主页:<a href="http://odegooglecom/p/smhasher/%E3%80%82">http://odegooglecom/p/smhasher/。</a></p><h2 id="4-3-解决键冲突"><a href="#4-3-解决键冲突" class="headerlink" title="4.3 解决键冲突"></a>4.3 解决键冲突</h2><p>​<strong>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突(collision)。</strong></p><p>​<strong>Redis 的哈希表使用链地址法(separate chaining)来解决键冲突，每个哈希表节点都有一个next 指针，多个哈希表节点可以用next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来</strong>，这就解决了键冲突的问题。</p><p>​举个例子，假设程序要将键值对 k2 和 v2 添加到图4-6所的哈希表里面，并且计算得出 k2 的索引值为2，那么键k1和 k2将产生冲突，而解决冲突的办法就是使用next 指针将键 k2 和 k1 所在的节点连接起来，如图4-7所示。因为 dictEntry 节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，序总是将新节点添加到链表的表头位置在其他有节点的前面。</p><p>​ <img src="/2023/09/21/blog-post2/image-20230214215010096.png" class=""></p><h2 id="4-4-rehash"><a href="#4-4-rehash" class="headerlink" title="4.4 rehash"></a>4.4 <strong>rehash</strong></h2><p>​<strong>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子(load factor)维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</strong><br>​扩展和收缩哈希表的工作可以通过执行 rehash (重新散列)作来完成Redis 对字典的哈希表执行 rehash 的步骤如下:</p><ol><li>为字典的 ht[1] 哈表分配空间，这个哈表的间大小取决于要执行的操作，以及 ht[0] 当前包含的键值对数量(也即是 ht[o].used 属性的值): <ol><li>如果执行的是扩展操作，那么ht[1] 的大小为第一个大于等于 ht[0].used*2 的  2的n次方幂;</li><li>如果执行的是收缩操作，那么ht[1] 的大小为第一个大于等于 ht[0].used 的 2的n次方幂</li></ol></li><li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1]上面:rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了 ht[1]之后(ht[0] 变为空表)，释放ht[0]，将ht[11设置为ht[0]，并在 ht[1] 新创建一个空白哈希表，为下一次rehash做准备。</li></ol><h2 id="4-5-渐进式rehash"><a href="#4-5-渐进式rehash" class="headerlink" title="4.5 渐进式rehash"></a>4.5 渐进式rehash</h2><p>​<strong>上一节说过，扩展或收缩哈希表需要将 ht[0]里面的所有键值对 rehash 到 ht[1]里面，但是，这个rehash 动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</strong></p><p>​这样做的原因在于，如果 ht[0] 里只保存着四个键值对，那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1]; 但是，如果哈希表里保存的键值对数量不是四个，而是四百万、四千万甚至四亿个键值对，那么要一次性将这些键值对全部rehash到 ht[1] 的话庞大的计算量可能会导致服务器在一段时间内停止服务.</p><p>​因此，为了避免 rehash 对服务器性能造成影响，服务器不是一次性将 ht[0] 里面的所有键值对全部rehash 到 ht[1]，而是分多次、渐进式地将 ht[0]里面的键值对慢慢地 rehash到ht[1].</p><p><strong>渐进式rehash执行期间的哈希表操作</strong></p><p>​因为在进行渐进式rehash 的过程中，字典会同时使用 ht[0] 和ht[1]两个哈希表所以在渐进式rehash 进行期间，字典的删除 (delete)查找 (find)更新(update)等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在 ht[0] 里面进行查找，如果没找到的话，就会继续到 ht[1] 里面进行查找，诸如此类。另外，在进式rehash 执行期间，新添加到字典的键值对一律会被保存到 ht1]里面而 ht[0] 则不再进行任何添加操作，这一措施保证了 ht[0] 包含的键值对数量会只减不增，并随着 rehash 操作的执行而最终变成空表。</p><h2 id="4-6-字典API"><a href="#4-6-字典API" class="headerlink" title="4.6 字典API"></a>4.6 字典API</h2><img src="/2023/09/21/blog-post2/image-20230214220859974.png" class=""><h2 id="4-7-重点回顾"><a href="#4-7-重点回顾" class="headerlink" title="4.7 重点回顾"></a>4.7 重点回顾</h2><ul><li><strong>字典被广泛用于实现 Redis 的各种功能，其中包括数据库和哈希键</strong></li><li><strong>Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行 rehash 时使用</strong></li><li><strong>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用 MurmurHash2 算法来计算键的哈希值</strong></li><li><strong>哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表</strong></li><li><strong>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面，并且这个 rehash 过程并不是一次性地完成的，而是渐进式地完成的</strong></li></ul><h1 id="第5章-跳跃表"><a href="#第5章-跳跃表" class="headerlink" title="第5章 跳跃表"></a>第5章 跳跃表</h1><p>​<strong>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</strong><br><strong>跳跃表支持平均 (logN)、最坏 O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点</strong></p><p>​<strong>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。Redis 使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数比较多，又或者有序集合中元素的成员 (member)是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现</strong></p><p>​举个例子，fruit-price 是一个有序集合键，这个有序集合以水果名为成员，水果价钱为分值，保存了 130 款水果的价钱:</p><img src="/2023/09/21/blog-post2/image-20230214222941399.png" class=""><p>​fruit-price 有序集合的所有数据都保存在一个跳跃表里面，其中每个跳跃表节点(node)都保存了一款水果的价钱信息，所有水果按价钱的高低从低到高在跳跃表面排序</p><ul><li>跳跃表的第一个元素的成员为“banana”，它的分值为 5</li><li>跳跃表的第二个元素的成员为”cherry”，它的分值为 6.5</li><li>跳表的第三个元素的成员为“apple”，它的分值为 8</li></ul><p>和链表、字典等数据结构被广泛地应用在 Redis 内部不同，Redis 只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。除此之外，没有其他用途。</p><p>Redis 的跳跃表由 <code>redis.h/zskiplist  Noderedis.h/zskiplist</code> 两个结构定义，其中 zskiplistNode 结构用于表示跳跃表节点，而zskiplist 结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等</p><img src="/2023/09/21/blog-post2/image-20230217222355419.png" class=""><p>图5-1 展示了一个跳跃表示例，位于图片最左边的是 <strong>zskiplist</strong> 结构，该结构含以下属性:</p><ul><li><strong>header</strong>: 指向跳跃表的表头节点。</li><li><strong>tail</strong>: 指向跳跃表的表尾节点。</li><li><strong>level</strong>: 记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)。</li><li><strong>length</strong>: 记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)。</li></ul><p>位于 <strong>zskiplist</strong>  结构右方的是四个 <strong>zskiplistNode</strong> 结构，该结构包含以下属性:</p><p><strong>层(level)</strong>:  节点中用L1、L2、L3 等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。<strong>每个层都带有两个属性:前进指针和跨度</strong>。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。<strong>当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</strong></p><p><strong>后退 (backward)指针</strong>:  节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</p><p><strong>分值(score)</strong>: 各个节点中的1.0, 2.0 和 3.0是节点所保存的分值。在跳跃表中节点按各自所保存的分值从小到大排列。<br><strong>成员对象(obi)</strong>: 各个节点中的o1、02和o3 是节点所保存的成员对象。注意表头节点和其他节点的构造是一样的: <strong>表头节点也有后退指针和分值和成员对象</strong>，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p><h3 id="5-1-1-跳跃表节点"><a href="#5-1-1-跳跃表节点" class="headerlink" title="5.1.1 跳跃表节点"></a>5.1.1 跳跃表节点</h3><p>跳跃表节点的实现由  <code>redis.h/zskiplistNode</code>  结构定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">//层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-comment">//进指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>    <span class="hljs-comment">//跨度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span;<br>    &#125; level[];<br>    <span class="hljs-comment">//后退指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <span class="hljs-comment">//分</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">// 成员对象</span><br>    robj *obj;<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p><strong>1.层</strong><br>        跳跃表节点的 level 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p>​每次创建一个新跳跃表节点的时候，序都根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于 1和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”。</p><p>​图 5-2分别展示了三个高度为 1层、3 层 5 层节点，因为C 语言的数组索引总是从0开始的，所以节点的第一层是 level[0]，而第二层是 level[1]，以此类推</p><p><strong>2.前进指针</strong><br>每个层都有一个指向表尾方向的前进指针( level[i].forward 属性)，用于从表头向表尾方向访问节点。图5-3 用虚表示出了序从表头表尾方，历跳表中所有节点的路径:</p><img src="/2023/09/21/blog-post2/image-20230217225943520.png" class=""><ol><li>迭代程序首先访问跳表的第一个节点(表头)，然后从第四层的前进指针动到表中的第二个节点。</li><li>在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</li><li>在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点</li><li>当程序再次沿着第四个节点的前进指针移动时，它碰到一个 NULL，序知道这时已经到达了跳跃表的表尾，于是结束这次遍历</li></ol><p><strong>3.跨度</strong><br>        层的跨度( <code>level[i].span</code> 属性) 用于记录两个节点之间的距离</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向 NULL的所有前进指针的度都为，因为它们没有连向任何节点</li></ul><p>​<strong>初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的: 在查某个节点的过程中将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</strong></p><p>​举个例子，图 5-4 用虚线标记了在跳跃表中查找分值为 3.0 成员对象为 o3 的节点时沿途经历的层:查找的过程只经过了一个层，并且层的跨度为 3，所以目标节点在跳跃表中的排位为 3。</p><img src="/2023/09/21/blog-post2/image-20230217231049637.png" class=""><p>​再举个例子，图 5-5 用线标记了在跳跃表中查找分值为 2.0 成员对象为 o2 的节点时，沿途经历的层:在查找节点的过程中，程序经过了两个跨度为 1的节点，因此可以计算出，目标节点在跳跃表中的排位为 2。</p><img src="/2023/09/21/blog-post2/image-20230217231637360.png" class=""><p><strong>4.后退指针</strong></p><p>​<strong>节点的后退指针 (backward属性)用于从表尾向表头方向访问节点:跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点</strong>。</p><p>​图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点序首先通过跳表的 tail 指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向 NULL 的后退指针，于是访问结束。</p><img src="/2023/09/21/blog-post2/image-20230217233111478.png" class=""><p><strong>5.分值和成员</strong></p><p>​<strong>节点的分值(score 属性)是一个 double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</strong></p><p>​<strong>节点的成员对象(ob 属性)是一个指针，它指向一个字符对象，而字符串对象则保存着一个SDS值。【为什么是一个字符串】</strong></p><p>​<strong>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面(近表头的方向) ，而成员对象较大的节点则会排在后面(靠近表尾的方)。</strong></p><p>​举个例子，在图 5-7所示的跳跃表中，三个跳跃表节点都保存了相同的分值 10086.0 但保存成员对象 o1 的节点却排在保存成员对象02 和03 的节点之前，而保存成员对象2的节点又排在保存成员对象 o3 的节点之前，由此可见，01、02、03 三个成员对象在字典中的排序为 o1&lt;&#x3D;o2&lt;&#x3D;o3。</p><img src="/2023/09/21/blog-post2/image-20230217233235582.png" class=""><h3 id="5-1-2-跳跃表"><a href="#5-1-2-跳跃表" class="headerlink" title="5.1.2 跳跃表"></a>5.1.2 跳跃表</h3><p>​仅靠多个跳跃表节点就可以组成一个跳跃表，如图 5-8 所示。<strong>但通过使用一个 zskiplist 结构来持有这些节点，序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点</strong>，或者快速地获取跳跃表节点的数量(也即是跳跃表的长度)等信息，如   图 5-9 所。</p><p><code>zskiplist</code>  结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br><span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br><span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><img src="/2023/09/21/blog-post2/image-20230217233707203.png" class=""><p>header 和 tail  指针分别指向跳跃表的表头和表尾节点，通过这两个指针，序定位表头节点和表尾节点的复杂度为 O(1)。通过使用length 属性来记录节点的数量，序可以在 0(1)复杂度内返回跳表的长度leve1属性则用于在 0(1)复杂内取跳表中高最的那个节点的层数量，注意表头节点的层高并不计算在内。</p><h2 id="5-2-跳跃表API"><a href="#5-2-跳跃表API" class="headerlink" title="5.2 跳跃表API"></a>5.2 跳跃表API</h2><p>表5-1列出了跳表所有操作API</p><img src="/2023/09/21/blog-post2/image-20230217233915326.png" class=""><h2 id="5-3-重点回顾"><a href="#5-3-重点回顾" class="headerlink" title="5.3 重点回顾"></a>5.3 重点回顾</h2><ul><li>跳跃表是有序集合的底层实现之一</li><li>Redis的跳跃表实现由 zsiplist 和 zskiplistNode 两个结构组成，其中zskiplist用于保存跳跃表信息(比如表头节点、表尾节点长度)而zskiplstNode 则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是1至32之间的随机数。</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li></ul><p>参考： <a href="https://www.cnblogs.com/Laymen/p/14084664.html">https://www.cnblogs.com/Laymen/p/14084664.html</a></p><h1 id="第6章-整数集合"><a href="#第6章-整数集合" class="headerlink" title="第6章 整数集合"></a>第6章 整数集合</h1><p>​整数集合 (intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p><p>​举个例子，如果我们创建一个只包含五个元素的集合键，并且集合中的所有元素都是整数值，那么这个集合键的底层实现就会是整数集合:</p><img src="/2023/09/21/blog-post2/image-20230222213602549.png" class=""><h2 id="6-1-整数集合的实现"><a href="#6-1-整数集合的实现" class="headerlink" title="6.1 整数集合的实现"></a>6.1 整数集合的实现</h2><p>​整数集合 (intset)是 Redis 用于保存整数值的集合抽象数据结构，它可以保存类型为  int16_t、int32_t  或者  int64_t 的整数值，并且保证集合中不会出现重复元素。</p><p>​每个 intset.h&#x2F;intset  结构表示一个整数集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br><span class="hljs-comment">//编码方式</span><br>uint32 t encoding;<span class="hljs-comment">// 集合包舍的元素数量</span><br>    uint32 t length;<span class="hljs-comment">// 保存元素的数组</span><br>    int8 t contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><p>​contents 数组是整数集合的底层实现:整数集合的每个元素都是 contents 数组的个数组项(item)各个项在数中值的大小从小到大有排列，并且数组中不包含任何重复项。</p><p>​length 属性记录了整数集合包含的元素数量，也即是 contents 数组的长度。虽然intset 结构将contents 属性声明为int8 t类型的数组，但实际上contents数组并不保存任何 int8 t类型的值，contents 数组的真正类型取决于encoding 属性的值:</p><img src="/2023/09/21/blog-post2/image-20230222215827056.png" class=""><img src="/2023/09/21/blog-post2/image-20230222215854744.png" class=""><p>​虽然contents数组保存的四个整数值中，只有-2675 256 175 807981027是真正需要用int64 t类型来保存的，而其他的 1、3、5三个值都可以用int16t类型来保存，不过根据整数集合的升级规则，当向一个底层为 int16 t数组的整数集合添加一个 int64 t类型的整数值时，整数集合已有的所有元素都会被转换成 int64  类型，所以contents 数组保存的四个整数值都是int64 t类型的，不仅仅是-2675256175 807981027。</p><h2 id="6-6-重点回顾"><a href="#6-6-重点回顾" class="headerlink" title="6.6 重点回顾"></a>6.6 重点回顾</h2><ul><li>整数集合是集合键的底层实现之一。</li><li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。</li><li>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。</li><li>整数集合只支持升级操作，不支持降级操作。</li></ul><h1 id="第7章-压缩列表"><a href="#第7章-压缩列表" class="headerlink" title="第7章 压缩列表"></a>第7章 压缩列表</h1><p>​压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做列表键的底层实现。<br>​例如，执行以下命令将创建一个压缩列表实现的列表键</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis&gt; RPUSH lst 1 3 5 10086 <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-string">&quot;world&quot;</span><br>(<span class="hljs-built_in">integer</span>)6<br>redis&gt; OBJECT ENCODING lst<br>ziplist<br></code></pre></td></tr></table></figure><img src="/2023/09/21/blog-post2/image-20230222223058368.png" class=""><p>​列表键里面包含的都是 1、3、5、10086 这样的小整数值，以及”hello”、”world” 这样的短字符串。</p><p>​另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做哈希键的底层实现。</p><p>​举个例子，执行以下命令将创建一个压缩列表实现的哈希键:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis&gt; HMSET profile <span class="hljs-string">&quot;name&quot;</span> <span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-string">&quot;age&quot;</span> 28 <span class="hljs-string">&quot;job&quot;</span> <span class="hljs-string">&quot;programmer&quot;</span><br>OK<br>redis&gt; OBJECT ENCODING profile<br>ziplist<br></code></pre></td></tr></table></figure><img src="/2023/09/21/blog-post2/image-20230222224607586.png" class=""><h2 id="7-1-压缩列表的构成"><a href="#7-1-压缩列表的构成" class="headerlink" title="7.1 压缩列表的构成"></a>7.1 压缩列表的构成</h2><p>​压缩列表是 Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。一个压缩列表可以包含任意多个节点 (entry)，每个节点可以保存一个字节数组或者一个整数值。<br>​图7-1 展示了压缩列表的各个组成部分，表7-1 则记录了各个组成部分的类型、长度以及用途。</p><img src="/2023/09/21/blog-post2/image-20230222225225835.png" class=""><h2 id="7-2-压缩列表节点的构成"><a href="#7-2-压缩列表节点的构成" class="headerlink" title="7.2 压缩列表节点的构成"></a>7.2 压缩列表节点的构成</h2><p>​每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是以下三种长度的其中一种:</p><ul><li>长度小于等于63(2-1)字节的字节数组</li><li>长度小于等于16383(214-1)字节的字节数组</li><li>长度小于等于4294967295(22-1)字节的字节数组</li></ul><p>​而整数值则可以是以下六种</p><ul><li>长度的其中一种4 位长，介于0至12 之间的无符号整数</li><li>1字节长的有符号整数</li><li>3字节长的有符号整数</li><li>int16_t类型整数</li><li>int32_t类型整数</li><li>int64_t类型整数</li></ul><p>​每个压缩列表节点都由previous entry length、encoding、content 三个部分组成，如图7-4所示。<br>​接下来的内容将分别介绍这三个组成部分。</p><h2 id="7-5-重点回顾"><a href="#7-5-重点回顾" class="headerlink" title="7.5 重点回顾"></a>7.5 重点回顾</h2><ul><li><strong>压缩列表是一种为节约内存而开发的顺序型数据结构</strong></li><li><strong>压缩列表被用作列表键和哈希键的底层实现之一</strong></li><li><strong>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</strong></li><li><strong>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作但这种操作出现的几率并不高</strong></li></ul><h1 id="第8章-对象（重点）"><a href="#第8章-对象（重点）" class="headerlink" title="第8章 对象（重点）"></a>第8章 对象（重点）</h1><p>​在前面的数个章节里，我们陆续介绍了 Redis 用到的所有主要数据结构，比如简单动态字符串(SDS)、双端链表、字典、缩列表、整数集合等等。</p><p>​<strong>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。</strong></p><p>​<strong>通过这五种不同类型的对象，Redis 可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。</strong>使用对象的另一个好处是，我们可以针对不同的使用场景为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p><p>​除此之外，<strong>Redis 的对象系统还实现了基于引用计数技术的内存回收机制</strong>，当<strong>程序不再使用</strong>某个对象的时候，这个对象所占用的内存就会被自动释放;另外，<strong>Redis 还通过引用计数技术实现了对象共享机制</strong>，这一机制可以在适当的条件下，通过让多个数据库键共享同个对象来节约内存。<br>​最后，<strong>Redis 的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长</strong>，在服务器启用了 maxmemory 功能的情况下，<strong>空转时长较大的那些键可能会优先被服务器删除</strong>。</p><h2 id="8-1-对象的类型与编码"><a href="#8-1-对象的类型与编码" class="headerlink" title="8.1  对象的类型与编码"></a>8.1  对象的类型与编码</h2><p>​Redis 使用对象来表示数据库中的键和值，**每次当我们在 Redis 的数据中新建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键(键对象） 另一个对象用作键值对的值(值对象)**。</p><p>​举个例子，以下SET命令在数据库中创建了一个新的键值对，其中键值对的键是一个包含了字符串值 “ms” 的对象，而键值对的值则是一个包含了字符值 “helloworld” 的对象:</p><p>​Redis中的每个对象都由一个 redisobject 结构表示，该结构中和保存数据有关的三个属性分别是 type 属性、encoding 属性和 ptr 属性:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br><span class="hljs-comment">//类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br><span class="hljs-comment">//编码</span><br><span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//指向底层实现数据结构的指针</span><br>    <span class="hljs-type">void</span> *ptr;<br>    <span class="hljs-comment">//</span><br>    ...<br>&#125; robj;<br></code></pre></td></tr></table></figure><h3 id="8-1-1-类型"><a href="#8-1-1-类型" class="headerlink" title="8.1.1 类型"></a>8.1.1 类型</h3><p>​对象的 type 属性记录了对象的类型，这个属性的值可以是表8-1 列出的常量的其中一个</p><img src="/2023/09/21/blog-post2/image-20230222232145895.png" class=""><p>​对于 Redis 数据库保存的键值对来说，<strong>键总是一个字符串对象</strong>，而<strong>值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种</strong>，因此:</p><ul><li>当我们称呼一个数据库键为 “字符串键” 时我们指的是 “这个数据库键所对应的值为字符串对象”</li><li>当我们称呼一个键为 “列表键” 时，我们指的是 “这个数据键所对应的值为列表对”</li></ul><p>​<strong>TYPE</strong>  命令的实现方式也与此类似，当我们对一个数据库键执行 TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型:</p><img src="/2023/09/21/blog-post2/image-20230222232454683.png" class=""><h3 id="8-1-2-编码和底层实现"><a href="#8-1-2-编码和底层实现" class="headerlink" title="8.1.2 编码和底层实现"></a>8.1.2 编码和底层实现</h3><p>​对象的ptr 指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p><p>​encoding 属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是表 8-3 列出的常量的其中一个。</p><img src="/2023/09/21/blog-post2/image-20230223212453344.png" class=""><p>​<strong>每种类型的对象都至少使用了两种不同的编码，表8-4列出了每种类型的对象可以使用的编码。</strong></p><img src="/2023/09/21/blog-post2/image-20230223213413003.png" class=""><p>​使用 OBJECT  ENCODING 命令可以查看一个数据库键的值对象的编码</p><img src="/2023/09/21/blog-post2/image-20230223213917408.png" class=""><img src="/2023/09/21/blog-post2/image-20230223214008230.png" class=""><p>​<strong>通过 encoding 属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了 Redis 的灵活性和效率</strong>，因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p><p>​举个例子，在列表对象包含的元素比较少时，Redis 使用缩列表作为列表对象的底层实现</p><ul><li>因为<strong>压缩列表比双端链表更节约内存</strong>，并且在<strong>元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中</strong>; </li><li>随着<strong>列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时</strong>，对象就会将底层实现从压缩列表转向<strong>功能更强、也更适合保存大量元素的双端链表</strong>上面;</li></ul><p>​其他类型的对象也会通过使用多种不同的编码来进行类似的优化。在接下来的内容中，我们将分别介绍 <strong>Redis 中的五种不同类型的对象，说明这些对象底层所使用的编码方式</strong>，列出对象从一种编码转换成另一种编码所需的条件，以及同一个命令在多种不同编码上的实现方法。</p><h2 id="8-2-字符串对象"><a href="#8-2-字符串对象" class="headerlink" title="8.2 字符串对象"></a>8.2 字符串对象</h2><p>​<strong>字符串对象的编码可以是 int、raw 或者 embstr</strong></p><p>​ 如果一个<strong>字符串对象保存的是整数值</strong>，并且这个整数值可以用 long 类型来表示，那么<strong>字符串对象会将整数值保存在字符串对象结构的 ptr 属性里</strong>面(将 void* 转换成 long)并将字符串对象的编码设置为 int。</p><img src="/2023/09/21/blog-post2/image-20230223220605551.png" class=""><p>​如果字符串对象保存的是一个<strong>字符串值，并且这个字符串值的长度大于 32 字节，那么字符串对象将使用一个简单动态字符(SDS)来保存这个符，并将对象的编码设为 raw</strong></p><img src="/2023/09/21/blog-post2/image-20230223220708962.png" class=""><p>​如果字符串对象保存的是一个<strong>字符串值，并且这个字符串值的长度小于等于 32 字节那么字符串对象将使用embstr 编码的方式来保存这个字符串值</strong>。embstr 编码是专门用于保存短字符的一种优化编码方式，这种编码 raw 编一样，都使用 redisobject 结构和 sdshdr 结构来表示字符申对象，但raw编码会调用两次内存分配函数来分别创建redisobject 结构和 sdshdr 结构，而embstr 编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含 redisobject 和 sdshdr两个结构，如图 8-3 所示。</p><img src="/2023/09/21/blog-post2/image-20230223221539610.png" class=""><h3 id="8-2-1-编码的转换"><a href="#8-2-1-编码的转换" class="headerlink" title="8.2.1 编码的转换"></a>8.2.1 编码的转换</h3><p>​<strong>int 编码的字符串对象和embstr 编码的字符对象在条件满足的情况下，会被转换为 raw 编码的字符对象。</strong></p><p>​对于 int 编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从 int 为 raw。</p><p>​在下面的示例中，我们通过APPEND命令，向一个保存整数值的字符串对象追加了个字符串值，因为追加操作只能对字符串值执行，所以程序会先将之前保存的整数值10086转换为字符串值“10086”，然后再执行追加操作，操作的执行结果就是一个raw编码的、保存了字符串值的字符串对象:</p><img src="/2023/09/21/blog-post2/image-20230223221650576.png" class=""><h3 id="8-2-2-字符串命令的实现"><a href="#8-2-2-字符串命令的实现" class="headerlink" title="8.2.2  字符串命令的实现"></a>8.2.2  字符串命令的实现</h3><p>​因为字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的，表8-7 列举了其中一部分字符命令，以及这些命在不同编码的字符对象下的实现方法。</p><h2 id="8-11-重点回顾"><a href="#8-11-重点回顾" class="headerlink" title="8.11 重点回顾"></a>8.11 重点回顾</h2><ul><li>Redis 数据库中的每个键值对的键和值都是一个对象</li><li>Redis 共有字符、列表、哈、合、有合五种类型的对象，每种型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率</li><li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型</li><li>Redis 的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放</li><li>Redis 会共享值为0到 9999 的字符串对象</li><li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间</li></ul><h1 id="第9章-数据库-重点、重点"><a href="#第9章-数据库-重点、重点" class="headerlink" title="第9章 数据库(重点、重点)"></a>第9章 数据库(重点、重点)</h1><p>​本章将对 Redis 服务器的数据库实现进行详细介绍，说明服务器保存数据库的方法，客户端切换数据库的方法，数据库保存键值对的方法，以及针对数据库的添加、删除、查看更新操作的实现方法等。除此之外，本章还会说明服务器保存键的过期时间的方法，以及服务器自动删除过期键的方法。最后，本章还会说明 Redis 2.8 新引人的数据通知功能的实。</p><h2 id="9-1-服务器中的数据库"><a href="#9-1-服务器中的数据库" class="headerlink" title="9.1 服务器中的数据库"></a>9.1 服务器中的数据库</h2><p>​Redis 服务器将所有数据库都保存在服务器状态 redis.h&#x2F;redisServer 结构的db数组中，db 数组的每个项都是一个redis.h&#x2F;redisDb 结构，每个redisDb 结构代表个数据库</p><p>​dbnum 属性的值由服务器配置的 database 选项决定，默认情况下，该选项的值为所以 Redis 服务器默认会创建 16 个数据库，如图 9-1 所示。<img src="/2023/09/21/blog-post2/image-20230226205956889.png" class=""></p><h2 id="9-2-切换数据库"><a href="#9-2-切换数据库" class="headerlink" title="9.2 切换数据库"></a>9.2 切换数据库</h2><p>​每个Redis客户端都有自已的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p><p>​默认情况下，Redis 客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命今来切换目标数据库。<br>​以下代码示例演示了客户端在0号数据库设置并读取键 msg，之后切换到2号数据库并执行类似操作的过程:</p><img src="/2023/09/21/blog-post2/image-20230226210323429.png" class=""><p>​redisclient.db 指针指向 redisServer.db 数组的其中一个元素，而被指向的元素就是客户端的目标数据库。<br>​比如说，如果某个客户端的目标数据库为 1号数据库，那么这个客户端所对应的客户端状态和服务器状态之间的关系如图 9-2 所示。</p><img src="/2023/09/21/blog-post2/image-20230226210924733.png" class=""><p>如果这时客户端执行命令 SELECT 2  将目标数据库改为 2 号数据库，那么客户端状态和服务器状态之间的关系将更新成图 9-3。</p><img src="/2023/09/21/blog-post2/image-20230226210957792.png" class=""><p>通过修改 redisclient.db 指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能一这就是 SELECT 命今的实现原理。</p><h2 id="9-3-数据库键空间"><a href="#9-3-数据库键空间" class="headerlink" title="9.3 数据库键空间"></a>9.3 数据库键空间</h2><p>​<strong>Redis 是一个键值对( key-value pair)数据服务器，服务器中的每个数据库都由个redis.h&#x2F;redisDb 结构表示，其中，redisDb 结构的 dict 字典保存了数据库中的所有键值对，我们将这个字典称为键空间(key space):</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br><span class="hljs-comment">// 数据库键空间，保存着数据库中的所有键值对</span><br>    dict *dict;<br><span class="hljs-comment">// ..... </span><br>&#125; redisDb;<br></code></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的:</p><ul><li><strong>键空间的键也就是数据库的键，每个键都是一个字符串对象</strong></li><li><strong>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈表对象集合对象和有序集合对象中的任意一种 Redis 对象</strong></li></ul><p>举个例子，如果我们在空白的数据库中执行以下命令:</p><img src="/2023/09/21/blog-post2/image-20230226215753114.png" class=""><p>那么在这些命令执行之后，数据库的键空间将会是图 9-4 所展示的样子</p><ul><li><p>alphabet 是一个列表键，键的名字是一个包含字符串”alphabet”的字符串对象，键的值则是一个包含三个元素的列表对象。</p></li><li><p>book 是一个哈希表键，键的名字是一个包含字符串“book”的字符串对象，键的值则是一个包含三个键值对的哈希表对象</p></li><li><p>message是一个字符串键，键的名字是一个包含字符串“message”的字符申对象键的值则是一个包含字符串“hello world”的字符串对象</p></li></ul><img src="/2023/09/21/blog-post2/image-20230226215954763.png" class=""><p>​<strong>因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的</strong>，以下几个小节将分别介绍数据库的添加、删除、更新、取值等操作的实现原理。</p><h3 id="9-3-1-添加新键"><a href="#9-3-1-添加新键" class="headerlink" title="9.3.1 添加新键"></a>9.3.1 添加新键</h3><p>​<strong>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的 Redis 对象</strong>。举个例子，如果键空间当前的状态如图 9-4 所示，那么在执行以下命令之后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis&gt; SET <span class="hljs-built_in">date</span> <span class="hljs-string">&quot;2013.12.1&quot;</span><br>OK<br></code></pre></td></tr></table></figure><h3 id="9-3-2-删除键"><a href="#9-3-2-删除键" class="headerlink" title="9.3.2 删除键"></a>9.3.2 删除键</h3><p>​删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象举个例子，如果键空间当前的状态如图 9-4 所示，那么在执行以下命令之后:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis&gt; DEL book<br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><h3 id="9-3-3-更新键"><a href="#9-3-3-更新键" class="headerlink" title="9.3.3 更新键"></a>9.3.3 更新键</h3><p>​对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。举个例子，如果键空间当前的状态如图 9-4 所示，那么在执行以下命令之后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis&gt; SET message <span class="hljs-string">&quot;blah blah&quot;</span><br>OK<br></code></pre></td></tr></table></figure><h3 id="9-3-4-对键取值"><a href="#9-3-4-对键取值" class="headerlink" title="9.3.4 对键取值"></a>9.3.4 对键取值</h3><p>​对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。举个例子，如果键空间当前的状态如图 9-4 所示，那么当执行以下命令时:<br><code>redis&gt; GET message &quot;hello world&quot;</code><br>GET命令将首先在键空间中查找键 message，找到键之后接着取得该键所对应的字符串对象值，之后再返回值对象所包含的字符串”hello world”，取值过程如图9-9所示。</p><h3 id="9-3-5其他键空间操作"><a href="#9-3-5其他键空间操作" class="headerlink" title="9.3.5其他键空间操作"></a>9.3.5其他键空间操作</h3><p>​除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的 Redis命令，也是通过对<strong>键空间</strong>进行处理来完成的。<br>​比如说，用于清空整个数据库的 FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的 RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。<br>​另外，用于返回数据库键数量的 DBSIZE令，就是通过返回键空间中包含的键值对的数量来实现的。似的命令还有EXISTS、RENAME、KEYS等，这些命都是通过对键空间进行操作来实现的。</p><h3 id="9-3-6-读写键空间时的维护操作"><a href="#9-3-6-读写键空间时的维护操作" class="headerlink" title="9.3.6 读写键空间时的维护操作"></a>9.3.6 读写键空间时的维护操作</h3><p>​当使用 Redis 命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作还会执行一些额外的维护操作，其中包括:</p><ul><li>在读取一个键之后(读操作和写操作都要对键进行读取)，服务器会根据键是否存在0来更新服务器的键空间命中(hit)次数或键空间不命中(iss)次数，这两个值可以在INFOstats 命令的 eyspace hits 属性和 keyspace misses 性中查看。</li><li>在读取一个键之后，服务器会更新键的 LRU(最后一次使用)时间，这个值可以用于计算键的闲置时间，使用 OBJECT idletime <key>  命今可以查看键 key 的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键然后才执行余下的其他操作，本章稍后对过期键的讨论会详细说明这一点</li><li>如果有客户端使用 WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏(dirty)，从而让事务序注意到这个键已经被修改过，第 19 章会详细说明这一点。<br>服务器每次修改一个键之后，都会对脏(dirty)键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作，第 10 章第11 章第 15 章都说到这一点。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知，本竟稍后讨论数据库通知功能的实现时会详细说明这一点。</li></ul><h2 id="9-4-设置键的生存时间或过期时间"><a href="#9-4-设置键的生存时间或过期时间" class="headerlink" title="9.4 设置键的生存时间或过期时间"></a>9.4 设置键的生存时间或过期时间</h2><p>​<strong>通过EXPIRE命令或者 PEXPIRE命令</strong>，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间(<strong>Time To Live，TTL</strong>)在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key value<br>OK<br>127.0.0.1:6379&gt; get key<br><span class="hljs-string">&quot;value&quot;</span><br>127.0.0.1:6379&gt; expire key 3<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; get key<br>(nil)<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure><p>​与 EXPIRE 命令和PEXPIRE命令类似，<strong>客户端可以通过EXPIREAT命令或PEXPIREAT命令</strong>，以秒或者毫秒精度给数据库中的某个键设置过期时间(expire time)。过期时间是一个UNIX 时间截，当键的过期时间来临时，服务器就会自动从数据库中删除这个键:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key value<br>OK<br>127.0.0.1:6379&gt; get key<br><span class="hljs-string">&quot;value&quot;</span><br>127.0.0.1:6379&gt; time<br>1) <span class="hljs-string">&quot;1677421823&quot;</span><br>2) <span class="hljs-string">&quot;642250&quot;</span><br>127.0.0.1:6379&gt; expireat key 1677421830<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; time<br>1) <span class="hljs-string">&quot;1677421833&quot;</span><br>2) <span class="hljs-string">&quot;292209&quot;</span><br>127.0.0.1:6379&gt; get key<br>(nil)<br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure><p>​<strong>TTL命令和 PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间</strong>，也就是，返回距离这个键被服务器自动删除还有多长时间:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key value<br>OK<br>127.0.0.1:6379&gt; expire key 1000<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; ttl key<br>(<span class="hljs-built_in">integer</span>) 989<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure><h3 id="9-4-1-设置过期时间"><a href="#9-4-1-设置过期时间" class="headerlink" title="9.4.1 设置过期时间"></a>9.4.1 设置过期时间</h3><p>​Redis 有四个不同的命今可以用于设置键的生存时间(键可以存在多)或过期时间(键什么时候会被删除):</p><ul><li>EXPIRE  <key> <ttl>  命今用于将键 key的生存时间设置为 ttl 秒</li><li>PEXPIRE  <key> <ttl> 命今用于将键 key 的生存时间设置为 ttl 毫秒</li><li>EXPIREAT <key>  <timestamp> 命令用于将键key的过期时间设置为 timestamp</li><li>PEXPIREAT <key>  <timestamp>  命今用于将键key的过期时间设置为 timestamp 所指定的毫秒数时间戳</li></ul><p>​<strong>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</strong>:无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行 PEXPIREAT命令一样。</p><h3 id="9-4-2-保存过期时间"><a href="#9-4-2-保存过期时间" class="headerlink" title="9.4.2 保存过期时间"></a>9.4.2 保存过期时间</h3><p>​redisDb 结构的expires 字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典:</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象(也即是某个数据库键)</li><li>过期字典的值是一个 long long 类型的整数，这个整数保存了键所指向的数据库键的过期时间一个毫秒精度的 UNIX 时间戳</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br><span class="hljs-comment">// 过期字典，保存着键的过期时间</span><br>    dict *expires;<br>&#125; redisDb;<br></code></pre></td></tr></table></figure><img src="/2023/09/21/blog-post2/image-20230226224203390.png" class=""><p>以下是 PEXPIREAT命令的伪代码定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">PEXPIREAT</span>(<span class="hljs-params">key, expire time <span class="hljs-keyword">in</span> ms</span>):<br><span class="hljs-comment"># 如果给定的键不存在于键空间，那么不能设置过期时间</span><br>    <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> redisDb.<span class="hljs-built_in">dict</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-comment"># 在过期字典中关联键和过期时间</span><br>    redisDb.expires[key] = expire_time_in_ms<br><span class="hljs-comment"># 过期时间设置成功</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="9-4-3-移除过期时间"><a href="#9-4-3-移除过期时间" class="headerlink" title="9.4.3 移除过期时间"></a>9.4.3 移除过期时间</h3><p>​<strong>PERSIST命令可以移除一个键的过期时间</strong></p><h3 id="9-4-4计-算并返回剩余生存时间"><a href="#9-4-4计-算并返回剩余生存时间" class="headerlink" title="9.4.4计 算并返回剩余生存时间"></a>9.4.4计 算并返回剩余生存时间</h3><p>​TTL 命令以秒为单位返回键的剩余生存时间，而PTTL则以秒为单位返回键的剩余生存时间:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis&gt; PEXPIREAT alphabet 1385877600000(<span class="hljs-built_in">integer</span>) 1<br>redis&gt; TTL alphabet(<span class="hljs-built_in">integer</span>) 8549007<br>redis&gt; PTTL alphabet(<span class="hljs-built_in">integer</span>) 8549001011<br></code></pre></td></tr></table></figure><h2 id="9-5-过期键删除策略"><a href="#9-5-过期键删除策略" class="headerlink" title="9.5 过期键删除策略"></a>9.5 过期键删除策略</h2><p>​经过上一节的介绍，我们知道了数据库键的过期时间都保存在过期字典中，又知道了如何根据过期时间去判断一个键是否过期，现在剩下的问题是:如果一个键过期了，那么它什么时候会被删除呢?<br>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略: </p><ul><li>定时删除:在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作</li><li>惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键</li><li>定期删除:每隔一段时间，序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定</li></ul><p>在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略</p><h3 id="9-5-1-定时删除"><a href="#9-5-1-定时删除" class="headerlink" title="9.5.1 定时删除"></a>9.5.1 定时删除</h3><p>​<strong>定时删除策略对内存是最友好的:通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</strong><br>​<strong>另一方面，定时删除策略的缺点是，它对 CPU 时间是最不友好的:在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU 时间，</strong>在内存不紧张但是 CPU时间非常紧张的情况下，将 CPU 时间用在删除和当前任务无关的过期键上，无疑会对服务器<br>的响应时间和吞吐量造成影响。例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将 CPU 时间用在处理客户端的命请求上面，而不是用在删除过期键上面除此之外，创建一个定时器需要用到 Redis 服务器中的时间事件，而当前时间事件的实现方式一一无序链表，查找一个事件的时间复杂度为 0(M并不能高效地处理大时间事件。<br>因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实</p><h3 id="9-5-2-情性删除"><a href="#9-5-2-情性删除" class="headerlink" title="9.5.2 情性删除"></a>9.5.2 情性删除</h3><p>​<strong>惰性删除策略对 CPU 时间来说是最友好的:序只会在取出键时才对键进行过期检查这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何 CPU 时间。惰性删除策略的缺点是，它对内存是最不友好的:如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。</strong>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除(除非用户手动执行 FLUSHDB)，我们甚至可以将这种情况看作是一种内存泄漏-无用的垃圾数据占用了大量的内存，而服务器却不会自已去释放它们，这对于运行状态非常依赖于内存的 Redis 服务器来说，肯定不是一个好消息。举个例子，对于一些和时间有关的数据，比如日志 (10g)，在某个时间点之后，对它们的访问就会大大减少，甚至不再访问，如果这类过期数据大量地积压在数据库中，用户以为服务器已经自动将它们删除了，但实际上这些键仍然存在，而且键所占用的内存也没有释放，那么造成的后果肯定是非常严重的。</p><h3 id="9-5-3-定期删除"><a href="#9-5-3-定期删除" class="headerlink" title="9.5.3 定期删除"></a>9.5.3 定期删除</h3><p>​从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷:</p><p>​定时删除占用太多CPU 时间，影响服务器的响应时间和吞吐量。</p><p>​惰性删除浪费太多内存，有内存泄漏的危险</p><p>​<strong>定期删除策略是前两种策略的一种整合和折中</strong><br>​<strong>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</strong><br> 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。<br>定期删除策略的难点是确定删除操作执行的时长和频率:口 如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将 CPU 时间过多地消耗在删除过期键上面。 如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和性删除策略一样，出现浪费内存的情况。<br>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p><h2 id="9-6-Redis-的过期键删除策略"><a href="#9-6-Redis-的过期键删除策略" class="headerlink" title="9.6 Redis 的过期键删除策略"></a>9.6 Redis 的过期键删除策略</h2><p>​<strong>在前一节，我们讨论了定时删除、惰性删除和定期删除三种过期键删除策略，Redis 服务器实际使用的是惰性删除和定期删除两种策略:通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU 时间和避免浪费内存空间之间取得平衡。</strong></p><h3 id="9-6-1-惰性删除策略的实现"><a href="#9-6-1-惰性删除策略的实现" class="headerlink" title="9.6.1 惰性删除策略的实现"></a>9.6.1 惰性删除策略的实现</h3><img src="/2023/09/21/blog-post2/image-20230226225340395.png" class=""><h3 id="9-8-1发送通知"><a href="#9-8-1发送通知" class="headerlink" title="9.8.1发送通知"></a>9.8.1发送通知</h3><p>​发送数据库通知的功能是由 notify.c&#x2F;notifyKeyspaceEvent 函数实现的</p><p>​<code>void notifyKeyspaceEvent(int type, char *event, robj *key,int dbid);</code></p><p>​函数的 type 参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events 选项所选定的通知类型，从而决定是否发送通知</p><p>​event、keys 和 dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码、函数会根据 type 参数以及这三个参数来构建事通知的内容，以及接收通知的频道名</p><p>​每当一个 Redis 命令需要发送数据库通知的时候，该命令的实现函数就会调用notify-KeyspaceEvent 函数，并向函数传递传递该命令所引发的事件的相关信息。</p><h2 id="9-9-重点回顾"><a href="#9-9-重点回顾" class="headerlink" title="9.9 重点回顾"></a>9.9 重点回顾</h2><ul><li>Redis 服务器的所有数据库都保存在 redisServer.db 数组中，而数据库的数量则由 redisServer.dbnum 属性保存。</li><li>客户端通过<strong>修改目标数据库指针</strong>，让它指向 redisServer.db 数组中的不同元素来切换不同的数据库</li><li><strong>数据库主要由 dict 和expires 两个字典构成，其中 dict 字典负责保存键值对而expires字典则负责保存键的过期时间。</strong></li><li><strong>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</strong></li><li><strong>数据库的键总是一个字符对象，而值则可以是任意一种 Redis 对象类型</strong>，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符申键哈希表键、集合键、列表键和有序集合键。</li><li>expires 字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的 UNIX 时间戳</li><li>Redis 使用惰性除和定期删除两种策略来删除过期的键:性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</li><li>执行SAVE命令或者BGSAVE 命令所产生的新 RDB文件不会含已经过期的键</li><li>执行BGREWRITEAOF命今所产生的重AOF文件不会含已经过期的键当一个过期键被删除之后，服务器会追加一条 DEL 命令到现有 AOF 文件的末尾显式地删除过期键</li><li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条 DEL 命令，显式地删除过期键</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性</li><li>当Redis 命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知</li></ul><h1 id="第10章-RDB-持久化"><a href="#第10章-RDB-持久化" class="headerlink" title="第10章 RDB 持久化"></a>第10章 RDB <strong>持久化</strong></h1><p>​Redis 是一个键值对数据库服务器，服务器中通常含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将<strong>服务器中的非空数据库以及它们的键值对统称为数据库状态</strong>。</p><h2 id="10-1-RDB文件的创建与载入"><a href="#10-1-RDB文件的创建与载入" class="headerlink" title="10.1 RDB文件的创建与载入"></a>10.1 RDB文件的创建与载入</h2><p>​<strong>有两个 Redis 命令可以用于生成 RDB 文件，一个是SAVE，另一个是BGSAVE</strong></p><p>​<strong>SAVE命令会阻塞 Redis 服务器进程，直到RDB文件创建完毕为止，在服务器进阻塞期间，服务器不能处理任何命令请求</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; save    # 等待命令执行完成<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞雪如歌的小猪佩奇</title>
    <link href="/2023/09/15/my-blog-build-remark/"/>
    <url>/2023/09/15/my-blog-build-remark/</url>
    
    <content type="html"><![CDATA[<img src="/2023/09/15/my-blog-build-remark/posts-file-tree.jpg" class="" title="小猪佩奇"><p>红豆生南国，老公爱老婆。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/14/hello-world/"/>
    <url>/2023/09/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
